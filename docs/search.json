[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "hawkesNet",
    "section": "",
    "text": "Preface\nhawkesNet is an R package for fitting self-exciting network growth models. It is designed to support simulation studies, model comparison, and scalable inference on dynamic networks.\nThis e-book acts as both a guide to using the package, as well as a quick way to parse through documentation.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "hawkesNet",
    "section": "Installation",
    "text": "Installation\n\n# install.packages(\"devtools\")\ndevtools::install_github(\"JosephReps/hawkesNet\")",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "quick_start.html",
    "href": "quick_start.html",
    "title": "1  Quick Start",
    "section": "",
    "text": "The typical workflow is:\n\n  \n    \n      Input data\n      Two data frames: node arrivals + edge arrivals.\n    \n\n    →\n\n    \n      make_events()\n      Normalises times and builds event-indexed tables.\n    \n\n    →\n\n    \n      fit_hawkesNet()\n      Choose a kernel (BA / CS / bipartite) and fit.\n    \n  \n\nIf you haven’t already, install the package:\n\n# install.packages(\"devtools\")\ndevtools::install_github(\"JosephReps/hawkesNet\")\n\n\nReprEx\n\n# Our input data\n\n# Edge arrivals w/ times\nedges &lt;- data.frame(\n  i = c(1,1,3,1,4,1,4,2,9),\n  j = c(2,3,4,5,6,7,8,9,10),\n  time = 1:9\n)\n\n# Node arrivals w/ times\nnodes &lt;- data.frame(id = 1:10, time = 0:9)\n\n# Making the events object from our data\nev &lt;- make_events(nodes = nodes, edges = edges)\n\n# Fit the data using an appropriate kernel, in this case BA\nfit &lt;- fit_hawkesNet(\n  ev = ev,\n  params_init = list(mu = 1, K = 1, beta = 1, beta_edges = 1),\n  mark_type = \"ba\"\n)\n\nsummary(fit)\n\n\n\n\n\n\n\nNote\n\n\n\nIn the example above, we have taken special care to ensure the edges and nodes data frames satisfy the BA kernel assumptions. To learn more about this, head to the BA kernel page in the Example section.\n\n\n\n\nDiagnostics\nView model fit diagnostics.\n\npar(mfrow=c(1,2))\nplot(fit, type = \"tau_qq\")\nplot(fit, type = \"degree_hist\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Quick Start</span>"
    ]
  },
  {
    "objectID": "events.html",
    "href": "events.html",
    "title": "2  Events",
    "section": "",
    "text": "Input data frames\nhawkesNet is events-first. Instead of converting your data into a network object up-front, you provide node arrivals and edge arrivals as data frames, then call make_events() to convert them into the internal events representation used by simulation and fitting.\nAs stated, the two inputs are an edges and a nodes data frame.",
    "crumbs": [
      "Core Concepts",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Events</span>"
    ]
  },
  {
    "objectID": "events.html#input-data-frames",
    "href": "events.html#input-data-frames",
    "title": "2  Events",
    "section": "",
    "text": "Note\n\n\n\nThe nodes data frame is not required. Node arrival times can be inferred from the edge alone (make sure allow_implicit_births = TRUE when using make_events()). However, if you only pass edges, you cannot represent edgeless node arrivals, as the node only exists when it first appears in an edge.\n\n\n\nedges\n\n\n\n\n\n\n\n\n\nColumn\nType\nMeaning\nNotes\n\n\n\n\ni\ncharacter / integer\nTail/endpoint node id\nTogether with j identifies an edge between two nodes.\n\n\nj\ncharacter / integer\nHead/endpoint node id\nCurrent hawkesNet kernels treat edges as undirected (order doesn’t matter).\n\n\ntime\nnumeric\nEdge arrival time\nMust be \\(\\ge\\) both endpoint birth times in nodes (if provided).\n\n\n...\nany\nExtra edge attributes\nCarried through as edge attributes in the underlying network during fitting.\n\n\n\n\n\nnodes\n\n\n\n\n\n\n\n\n\nColumn\nType\nMeaning\nNotes\n\n\n\n\nid\ncharacter / integer\nNode identifier\nMust be unique within nodes. IDs used in edges$i/edges$j must match these.\n\n\ntime\nnumeric\nNode birth/arrival time\nCan be continuous or discrete. Must be comparable to edges$time.\n\n\nrole (optional)\ncharacter\nNode role/type  (e.g. \"event\", \"perp\")\nRequired for bipartite kernels (e.g. *_bip) if your mark model distinguishes node types.\n\n\n...\nany\nExtra node attributes\nCarried through as vertex attributes in the underlying network during fitting.",
    "crumbs": [
      "Core Concepts",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Events</span>"
    ]
  },
  {
    "objectID": "events.html#creating-events-objects",
    "href": "events.html#creating-events-objects",
    "title": "2  Events",
    "section": "Creating events objects",
    "text": "Creating events objects\n\nmake_events()\nYou can create events objects used for fitting by using the make_events() function.\n\n\n\n\n\n\n\n\nArgument\nWhat it is\nWhat it does\n\n\n\n\nnodes\ndata frame (optional)\nNode arrivals (id, time, …). If omitted, births can be inferred from edges (see below).\n\n\nedges\ndata frame (optional)\nEdge arrivals (i, j, time, …).\n\n\nallow_implicit_birth\nlogical\nIf TRUE and nodes is not supplied, infer node birth time as the first time the id appears in edges.\n\n\n...\noptional\nPackage may expose additional validation/behaviour flags (kept here to avoid duplicating implementation details in the docs).\n\n\n\n\n\nReturn value\nAn events object is a list with three data frames:\n\n\n\n\n\n\n\n\nComponent\nColumns\nMeaning\n\n\n\n\nev$times\nevent_id, t\nUnique sorted times used as event indices.\n\n\nev$nodes\nevent_id, id, …\nNode arrivals mapped onto event_id.\n\n\nev$edges\nevent_id, i, j, …\nEdge arrivals mapped onto event_id.",
    "crumbs": [
      "Core Concepts",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Events</span>"
    ]
  },
  {
    "objectID": "events.html#helpers",
    "href": "events.html#helpers",
    "title": "2  Events",
    "section": "Helpers",
    "text": "Helpers\nThere are a number of helpers included in the package to make working with the events objects easier:\n\ncreate_net_from_events(ev) → Create an events object from an network object.\ncreate_events_from_net(net) → Create an network object from an events object.\nnodes_by_event(ev) → list of node-arrival data frames (one per event_id)\nedges_by_event(ev) → list of edge-arrival data frames (one per event_id)\n\nSee the actual docs (eg. ?hawkesNet::create_net_from_events) for more information on these.",
    "crumbs": [
      "Core Concepts",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Events</span>"
    ]
  },
  {
    "objectID": "events.html#examples",
    "href": "events.html#examples",
    "title": "2  Events",
    "section": "Examples",
    "text": "Examples\n\nStandard\n\nnodes &lt;- data.frame(\n  id   = c(\"1\", \"2\", \"3\"),\n  time = c(0, 1, 2)\n)\nedges &lt;- data.frame(\n  i    = c(\"1\", \"1\"),\n  j    = c(\"2\", \"3\"),\n  time = c(1, 2)\n)\n\nev &lt;- make_events(nodes = nodes, edges = edges)\n\n\n\nImplicit births from edges\n\nedges_example &lt;- data.frame(\n  i    = c(\"1\", \"1\"),\n  j    = c(\"2\", \"3\"),\n  time = c(1, 2)\n)\n\nevents_from_edges &lt;- make_events(edges = edges_example, allow_implicit_birth = TRUE)\n\n\n\nNode & edge attributes\n\nnodes &lt;- data.frame(\n  id   = c(\"1\", \"2\", \"3\"),\n  time = c(0, 1, 2),\n  role = c(\"event\", \"perp\", \"perp\")\n)\nedges &lt;- data.frame(\n  i    = c(\"1\", \"1\"),\n  j    = c(\"2\", \"3\"),\n  time = c(1, 2),\n  attribute = c(\"strong\", \"weak\")\n)\n\nev &lt;- make_events(nodes = nodes, edges = edges)\n\nev$nodes\n\n  event_id id  role\n1        1  1 event\n2        2  2  perp\n3        3  3  perp\n\nev$edges\n\n  event_id i j attribute\n1        2 1 2    strong\n2        3 1 3      weak",
    "crumbs": [
      "Core Concepts",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Events</span>"
    ]
  },
  {
    "objectID": "simulation.html",
    "href": "simulation.html",
    "title": "3  Simulation",
    "section": "",
    "text": "Example\nSimulation is relatively straightforward for the core kernels (BA, BA_BIP, CS, BIP_CS).\nUses the usual hawkes Ogata thinning algorithm.\nSimulate data using the sim_hawkesNet() function. See ?hawkesNet::sim_hawkesNet for more information.\nset.seed(1)\n\nparams_ba &lt;- list(\n  mu = 5,\n  K = 0.5,\n  beta = 0.8,\n  beta_edges = 0.5\n)\n\ntime &lt;- 10\n\nsim &lt;- sim_hawkesNet(\n  params = params_ba,\n  T_end = time,\n  return_ev = TRUE,\n  debug = FALSE,\n  mark_type = \"ba\"\n)\n\n[1] \"Simulation took 0.33 seconds\"",
    "crumbs": [
      "Core Concepts",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Simulation</span>"
    ]
  },
  {
    "objectID": "simulation.html#return-value",
    "href": "simulation.html#return-value",
    "title": "3  Simulation",
    "section": "Return value",
    "text": "Return value\nSimulation object contains events, accept_probs, net and ev.\n\nevents\nContains the times and number of total events simulated:\n\nstr(sim$events)\n\nList of 2\n $ n: int 110\n $ t: num [1:110] 0.151 0.178 0.254 0.534 0.784 ...\n\n\n\n\naccept_probs\nContains the acceptance probabilities from the thinning for each event:\n\nstr(sim$accept_probs)\n\n num [1:112] 1 0.998 0.99 0.955 0.987 ...\n\n\n\n\nnet\nThe final network created from the events:\n\nplot(sim$net)\n\n\n\n\n\n\n\n\nNotice that the time attributes are preserved in the network object:\n\nsim$net\n\n Network attributes:\n  vertices = 110 \n  directed = FALSE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 121 \n    missing edges= 0 \n    non-missing edges= 121 \n\n Vertex attribute names: \n    time vertex.names \n\n Edge attribute names: \n    time \n\n\n\n\n\n\n\n\nTip\n\n\n\nAll the vertex attributes are preserved. Additionally, edge attributes are supported, so if custom kernels are written which utilize these later i.e. weighted edges, toggle-able edges etc., the current framework does not eed to change.\n\n\n\n\nev\nThe events object which can be plugged directly into fit_hawkesNet().\n\nstr(sim$ev)\n\nList of 3\n $ times:'data.frame':  110 obs. of  2 variables:\n  ..$ event_id: int [1:110] 1 2 3 4 5 6 7 8 9 10 ...\n  ..$ t       : num [1:110] 0.151 0.178 0.254 0.534 0.784 ...\n $ nodes:'data.frame':  110 obs. of  2 variables:\n  ..$ event_id: int [1:110] 1 2 3 4 5 6 7 8 9 10 ...\n  ..$ id      : chr [1:110] \"1\" \"2\" \"3\" \"4\" ...\n $ edges:'data.frame':  121 obs. of  3 variables:\n  ..$ event_id: int [1:121] 2 3 3 5 6 7 7 8 9 9 ...\n  ..$ i       : chr [1:121] \"1\" \"1\" \"2\" \"2\" ...\n  ..$ j       : chr [1:121] \"2\" \"3\" \"3\" \"5\" ...\n - attr(*, \"class\")= chr [1:2] \"events\" \"list\"",
    "crumbs": [
      "Core Concepts",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Simulation</span>"
    ]
  },
  {
    "objectID": "model_fitting.html",
    "href": "model_fitting.html",
    "title": "4  Model Fitting",
    "section": "",
    "text": "Example\nModel fitting requires an events object, created by make_events().\nFit models using fit_hawkesNet().\nFirst simulate some data (or use your own, and plug it into the make_events() function).\nset.seed(1)\n\nparams_ba &lt;- list(\n  mu = 2,\n  K = 0.5,\n  beta = 0.8,\n  beta_edges = 0.5\n)\n\ntime &lt;- 50\n\nsim &lt;- sim_hawkesNet(\n  params = params_ba,\n  T_end = time,\n  mark_type = \"ba\"\n)\n\n[1] \"Simulation took 1.06 seconds\"\n\nevents &lt;- sim$ev\nclass(events)\n\n[1] \"events\" \"list\"\nAnd then fitting the model. Make sure you specify a mark_type. Can be one of: ba, cs, ba_bip, cs_bip.\nparams_init &lt;- list(\n  mu = 5,\n  K = 0.3,\n  beta = 1,\n  beta_edges = 1\n)\n\nfit &lt;- fit_hawkesNet(\n    ev = sim$ev,\n    params_init = params_init,\n    mark_type = \"ba\"\n)\n\n[1] \"Fitting took 4.02 seconds\"\nAnd we can see the fitted values:\nunlist(fit$par)\n\n        mu          K       beta beta_edges \n 2.1922311  0.4817160  0.7720289  0.5505869\nNot terrible!\nInternally, the network is built incrementally event-by-event, for each iteration of the likelihood, rather than rebuilding the whole network up until that event, per-event.\nStill need to add a proper summary() function, as well as return std. errs. This should be really quick to implement, I’m just lazy.\nAlso eventually this page (as well as Simulation) would contain all the argument information.",
    "crumbs": [
      "Core Concepts",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Model Fitting</span>"
    ]
  },
  {
    "objectID": "diagnostics.html",
    "href": "diagnostics.html",
    "title": "5  Diagnostics",
    "section": "",
    "text": "5.1 Network diagnostics\nPackage tooling i.e. debugging plots, ks-test etc.\nA number of diagnostic plots are available for events and fit objects.\nFor the examples here, we will be using the fitted model from the previous section:\nYou can see all the network diagnostic plots available here:\n# Network diagnostic plots (2 columns)\ntypes_net &lt;- c(\"size\", \"edges_vs_nodes\", \"degree_hist\", \"degree_ccdf\")\n\noldpar &lt;- par(no.readonly = TRUE)\non.exit(par(oldpar), add = TRUE)\n\npar(mfrow = c(ceiling(length(types_net) / 2), 2), mar = c(4, 4, 2, 1))\ninvisible(lapply(types_net, function(tp) plot(sim$ev, type = tp)))",
    "crumbs": [
      "Core Concepts",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Diagnostics</span>"
    ]
  },
  {
    "objectID": "diagnostics.html#temporal-diagnostics",
    "href": "diagnostics.html#temporal-diagnostics",
    "title": "5  Diagnostics",
    "section": "5.2 Temporal diagnostics",
    "text": "5.2 Temporal diagnostics\nYou can see all the network diagnostic plots available here:\n\ntypes_time &lt;- c(\"count\", \"dt\", \"lambda\", \"tau_hist\", \"tau_qq\")\n\noldpar &lt;- par(no.readonly = TRUE)\non.exit(par(oldpar), add = TRUE)\n\npar(mfrow = c(2, 3), mar = c(4, 4, 2, 1))\n\nfor (tp in types_time) {\n  plot(fit, type = tp)\n}\n\nplot.new()",
    "crumbs": [
      "Core Concepts",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Diagnostics</span>"
    ]
  },
  {
    "objectID": "examples_ba.html",
    "href": "examples_ba.html",
    "title": "6  BA Kernel",
    "section": "",
    "text": "Kernel Specification\nThe BA kernel is a new-node attachment model: at each event time, exactly one new node arrives, and it connects to a subset of the already-existing nodes.\nIn the current hawkesNet implementation, the set of attachments is modelled as follows:\n\nLet \\(V(t^-)\\) be the set of existing (“old”) nodes right before the event at time \\(t\\).\nFor each old node \\(u \\in V(t^-)\\), the new node attaches to \\(u\\) independently with probability \\[\np_u(t) \\propto (d_u(t^-) + \\delta)\\,\\exp(-\\beta_{\\text{edges}}\\cdot \\text{age}_u(t)),\n\\] where \\(d_u(t^-)\\) is the current degree of \\(u\\), and \\(\\text{age}_u(t) = t - t_u\\) is how long ago node \\(u\\) arrived (using its stored node “time” attribute).\nThe probabilities are normalised over all old nodes so they sum to 1 before forming the Bernoulli probabilities used in the product model.\n\nIntuitively:\n\nHigher-degree nodes are more likely to receive a new connection (preferential attachment).\nIf \\(\\beta_{\\text{edges}} &gt; 0\\), older nodes are down-weighted via the exponential term (recency/aging effect).\n\\(\\delta\\) is a small smoothing constant so degree-zero nodes remain eligible.\n\nUnder this mark model, the probability of observing a particular set of attached old nodes is a product of Bernoulli terms over the old node set: \\[\n\\Pr(\\text{attachments at } t) = \\prod_{u \\in V(t^-)} p_u(t)^{I_u}\\,(1-p_u(t))^{1-I_u},\n\\] where \\(I_u = 1\\) if the new node attached to \\(u\\), and \\(I_u=0\\) otherwise.\n\n\n\nData Expectations\nTo use the BA kernel, your observed events must match the “new node arrives + connects to existing nodes” pattern:\n\nExactly one new node per event (one row in the node-arrivals data for each event time).\nAny edges at that event must connect that new node to existing nodes.\nWithin an event, you should not have the same old node attached multiple times (i.e., no duplicate new–old pair within the same event).\n\nEdge cases:\n\nIf there are no existing nodes yet, the event must have no edges (there is nobody to attach to).\nIf your data contains edges between two already-existing nodes, or repeated transactions/multi-edges between the same pair, then this BA mark model is not the right fit without extending the mark space / PMF.\n\n\n\n\nSimulation\nSimulate BA data:\n\n\n\n\nset.seed(1)\n\ntime &lt;- 50\nparams_ba_true &lt;- list(\n  mu = 0.5,\n  K = 0.5,\n  beta = 0.5,\n  beta_edges = 2\n)\n\nsim &lt;- sim_hawkesNet(\n  params = params_ba_true,\n  T_end = time,\n  mark_type = \"ba\"\n)\n\n[1] \"Simulation took 2.13 seconds\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModel fitting\nFit BA data.\n\nparams_ba_init &lt;- list(\n  mu = 1,\n  K = 1,\n  beta = 1,\n  beta_edges = 1\n)\n\nfit &lt;- fit_hawkesNet(\n      ev = sim$ev,\n      params_init = params_ba_init,\n      mark_type = \"ba\"\n    )\n\n[1] \"Fitting took 5.55 seconds\"\n\n\nParameter values on the fitted scale:\n\nunlist(fit$par)\n\n        mu          K       beta beta_edges \n 1.4169583  0.4623329  0.5102294  2.0408620 \n\n\nNot too bad.\nAnd, we can also grab parameter values on the transformed scale:\n\n# Yes I know this is a jank way to structure it right now, will fix\nfit$fit$par\n\n        mu          K       beta beta_edges \n 0.3485126 -0.7714700 -0.6728948  0.7133722 \n\n\n\n\n\n\n\n\nSee the simulation study results for the BA kernel here.",
    "crumbs": [
      "Kernels & Examples",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>BA Kernel</span>"
    ]
  },
  {
    "objectID": "examples_cs.html",
    "href": "examples_cs.html",
    "title": "7  CS Kernel",
    "section": "",
    "text": "Warning\n\n\n\nMy CS specification does NOT allow for marks to contain edges between two old nodes.\n\n\n\nKernel Specification\nThe CS (“change-statistic”) kernel is also a new-node attachment model, but instead of choosing attachment targets using degree weights (as in BA), it uses ERGM-style change statistics to score each possible new–old edge.\nAt each event time \\(t\\):\n\nA random number of new nodes arrives: \\[\nM_t \\sim \\text{Poisson}(\\lambda_{\\text{node}}),\n\\] (in the code this is node_lambda). Optionally, arrivals can be forced to stop after a cutoff time max_node_time (in which case \\(M_t\\) must be 0 for \\(t\\) past the cutoff).\nLet \\(V(t^-)\\) be the set of existing (“old”) nodes right before time \\(t\\), and let \\(N(t)\\) be the set of \\(M_t\\) new nodes arriving at time \\(t\\).\nThe model defines a candidate set of possible edges. In the current implementation, candidate edges are constructed deterministically as \\[\n\\{(u, v): u \\in N(t),\\; v \\in V(t^-)\\},\n\\] with an optional truncation that limits each new node to only consider the first truncation old nodes (according to the current ordering used internally) (Currently not implemented, argument doesn’t do anything but it’s not needed).\n\nFor each candidate edge \\((u, v)\\) (new node \\(u\\) to old node \\(v\\)), a vector of change statistics \\[\nC_{uv}(t)\n\\] is computed from the current network using the ERNM/ERGM-style specification you provide (via formula_rhs / computeChangeStats()).\nThese statistics are mapped to a baseline attachment probability using a logistic link: \\[\np^{(0)}_{uv}(t) = \\text{logit}^{-1}\\!\\left(C_{uv}(t)^\\top \\theta\\right).\n\\]\nFinally, an aging / recency adjustment is applied to down-weight older target nodes: \\[\np_{uv}(t) = p^{(0)}_{uv}(t)\\,\\exp\\!\\big(-\\beta_{\\text{edges}}\\cdot \\text{age}_v(t)\\big),\n\\] where \\(\\text{age}_v(t) = t - t_v\\) and \\(t_v\\) is the stored node arrival time. (In the implementation, probabilities are also clipped away from 0/1 for numerical stability.)\nUnder this mark model, each candidate edge is treated as an independent Bernoulli trial, so the probability of observing a particular set of edges at time \\(t\\) is a Bernoulli-product over the candidate set.\n\n\n\nData Expectations\nTo use the CS kernel, your events must match the “new nodes arrive + may connect to existing nodes” pattern:\n\nEach event time can introduce zero or more new nodes.\nAny edges observed at that event must be between a new node and an old node.\n\nImportantly (based on the current PMF / validators):\n\nOld–old edges are not allowed (edges between two already-existing nodes).\nNew–new edges are not allowed.\nSelf-loops are not allowed.\nWithin a single event, you should not repeat the same edge (no duplicates for a given unordered pair).\n\nIf your data includes edges forming between two existing nodes (e.g., repeated interactions/transactions, new ties between old users, etc.), then the current CS mark model is not appropriate without extending the mark space / PMF.\n\n\n\nSimulation\nSimulate CS data.\n\n\n\n\nset.seed(1)\n\ntime &lt;- 15\nparams_cs_true &lt;- list(\n  mu = 5,\n  K = 0.5,\n  beta = 2,\n  beta_edges = 0.5,\n  node_lambda = 4,\n  # CS_edges = -2.5,\n  # CS_triangles = 0.001,\n  CS_star.2 = -1,\n  CS_star.3 = -3\n)\n\nsim &lt;- sim_hawkesNet(\n  params = params_cs_true,\n  T_end = time,\n  mark_type = \"cs\",\n  # formula_rhs = \"edges + triangles() \n  # + star(c(2,3))\",\n  formula_rhs = \"star(c(2,3))\"\n)\n\n[1] \"Simulation took 0.99 seconds\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModel fitting\nFit CS data.\n\n\n\n\n\n\nTip\n\n\n\nMake sure to specify the transformation setting for the CS parameters.\nIdeally will default to correct value, but want to discuss how we are implementing the arguments, because lowk I like the old way of passing CS_params better.\n\n\n\nparams_cs_init &lt;- list(\n  mu = 3,\n  K = 1,\n  beta = 1,\n  beta_edges = 1,\n  node_lambda = 5,\n  # CS_edges = -2.5,\n  # CS_triangles = 0.001,\n  CS_star.2 = 0,\n  CS_star.3 = 0\n)\n\nfit &lt;- fit_hawkesNet(\n      ev = sim$ev,\n      params_init = params_cs_init,\n      mark_type = \"cs\",\n      transform = list(CS_star.2 = \"none\", CS_star.3 = \"none\"),\n      formula_rhs = \"star(c(2,3))\"\n    )\n\n[1] \"Fitting took 9.31 seconds\"\n\n\nParameter values on the fitted scale:\n\nunlist(fit$par)\n\n         mu           K        beta  beta_edges node_lambda   CS_star.2 \n  4.6384795   0.7236149   3.3119207   0.4046910   4.1888536  -0.9812649 \n  CS_star.3 \n -3.1691266 \n\n\nNotttt baddddd.\nParameter values on the transformed scale:\n\nfit$fit$par\n\n         mu           K        beta  beta_edges node_lambda   CS_star.2 \n  1.5343866  -0.3234959   1.1975283  -0.9046315   1.4324271  -0.9812649 \n  CS_star.3 \n -3.1691266",
    "crumbs": [
      "Kernels & Examples",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>CS Kernel</span>"
    ]
  },
  {
    "objectID": "examples_ba_bip.html",
    "href": "examples_ba_bip.html",
    "title": "8  BA-Bipartite Kernel",
    "section": "",
    "text": "Kernel Specification\nThe BA-Bipartite kernel is the bipartite analogue of the BA kernel: the network has two disjoint node sets (say Part A and Part B), and edges may only occur across parts (A–B), never within a part.\nAt each event time \\(t\\), exactly one new node arrives, and it attaches to a subset of already-existing nodes in the opposite part using a normalized degree-based weighting (with optional aging / recency down-weighting).\nConcretely:\n\nLet \\(V_A(t^-)\\) and \\(V_B(t^-)\\) be the sets of existing nodes in Parts A and B just before time \\(t\\).\nA single new node arrives in exactly one part (either A or B). Denote the new node by \\(v_{\\text{new}}\\) and its part by \\(P \\in \\{A,B\\}\\).\nThe candidate attachment targets are the old nodes in the other part: \\[\nV_{\\text{opp}}(t^-) =\n\\begin{cases}\n  V_B(t^-) & \\text{if } v_{\\text{new}} \\in A,\\\\\n  V_A(t^-) & \\text{if } v_{\\text{new}} \\in B.\n\\end{cases}\n\\]\n\nFor each candidate target \\(u \\in V_{\\text{opp}}(t^-)\\), the new node attaches to \\(u\\) independently with probability \\[\np_u(t) \\propto (d_u(t^-) + \\delta)\\,\\exp\\!\\big(-\\beta_{\\text{edges}}\\cdot \\text{age}_u(t)\\big),\n\\] where \\(d_u(t^-)\\) is the current (bipartite) degree of \\(u\\) right before time \\(t\\), and \\(\\text{age}_u(t) = t - t_u\\) is time since \\(u\\) arrived (from the stored node time attribute).\nThese weights are normalised over \\(V_{\\text{opp}}(t^-)\\) to form Bernoulli probabilities, and the probability of observing a specific attachment set is a product of Bernoulli terms over the opposite-part node set: \\[\n\\Pr(\\text{attachments at } t) = \\prod_{u \\in V_{\\text{opp}}(t^-)} p_u(t)^{I_u}\\,(1-p_u(t))^{1-I_u},\n\\] where \\(I_u=1\\) if an edge between \\(v_{\\text{new}}\\) and \\(u\\) is present at time \\(t\\), and \\(I_u=0\\) otherwise.\nIntuitively:\n\nNodes in the opposite part with higher degree are more likely to receive a new tie (preferential attachment).\nIf \\(\\beta_{\\text{edges}} &gt; 0\\), older nodes are down-weighted (recency/aging).\n\\(\\delta\\) is a small smoothing constant so degree-zero nodes remain eligible.\n\n\n\n\nData Expectations\nTo use the BA-Bipartite kernel, your observed events must represent a bipartite growth process where:\n\nEach node belongs to exactly one of two parts (A or B).\nEach event introduces exactly one new node (in either part).\nAny edges observed at that event must connect the new node to already-existing nodes in the opposite part.\n\nIn particular, the BA-Bipartite kernel assumes:\n\nNo within-part edges (no A–A or B–B edges).\nNo old–old edges (edges cannot form between two already-existing nodes).\nNo new–new edges (the new node cannot connect to another node that arrives at the same event).\nWithin an event, you should not repeat the same attachment (no duplicate new–old pair).\n\nEdge cases:\n\nIf the opposite part has no existing nodes yet (e.g. \\(V_{\\text{opp}}(t^-)=\\emptyset\\)), then the event must have no edges.\n\nIf your data contains edges between two already-existing nodes (e.g. repeated interactions/transactions), or edges within the same part, then this BA-Bipartite mark model is not an appropriate fit without extending the mark space / PMF.\n\n\n\nSimulation\nSimulate BIP-BA data.\n\n\n\n\nset.seed(1)\n\ntime &lt;- 10\nparams_bip_true &lt;- list(\n  mu = 0.5,\n  K = 0.5,\n  beta = 0.5,\n  beta_edges = 2,\n  lambda_new = 3.5\n)\n\nsim &lt;- sim_hawkesNet(\n  params = params_bip_true,\n  T_end = time,\n  mark_type = \"ba_bip\"\n)\n\n[1] \"Simulation took 0.19 seconds\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSee the code for this plot.\n\n\n\n\n\n\ncol_map &lt;- c(\n  event = \"#377EB8\",\n  perp  = \"#E41A1C\"\n)\n\nroles &lt;- network::get.vertex.attribute(sim$net, \"role\")\ncols &lt;- col_map[roles]\n\nop &lt;- par(no.readonly = TRUE)\non.exit(par(op), add = TRUE)\n\n# Add a little bottom space for legend\npar(mar = c(2.5,1,1,1), xaxs = \"i\", yaxs = \"i\")\n\nplot(sim$net, vertex.col = cols)\n\nlegend(\n  \"bottomleft\",\n  legend = c(\"Event\", \"Perp\"),\n  pch = 21,\n  pt.bg = col_map[c(\"event\", \"perp\")],  # fill colour\n  col = \"black\",                        # border colour\n  horiz = TRUE,\n  inset = 0.01,\n  xpd = TRUE,\n  cex = 2,\n  pt.cex = 2.5\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nModel fitting\nFit BIP-BA data.\n\nparams_bip_init &lt;- list(\n  mu = 1,\n  K = 1,\n  beta = 1,\n  beta_edges = 1,\n  lambda_new = 3.5\n)\n\nfit &lt;- fit_hawkesNet(\n      ev = sim$ev,\n      params_init = params_bip_init,\n      mark_type = \"ba_bip\"\n    )\n\n[1] \"Fitting took 0.39 seconds\"\n\n\nParameter values on the fitted scale:\n\nunlist(fit$par)\n\n        mu          K       beta beta_edges lambda_new \n 1.3977102  0.4811354  0.9347585  2.1233094  3.2400725 \n\n\nParameter values on the transformed scale:\n\nfit$fit$par\n\n         mu           K        beta  beta_edges  lambda_new \n 0.33483530 -0.73160664 -0.06746709  0.75297592  1.17559572 \n\n\n\n\n\n\n\n\nSee the simulation study results for the BA-BIP kernel here.",
    "crumbs": [
      "Kernels & Examples",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>BA-Bipartite Kernel</span>"
    ]
  },
  {
    "objectID": "examples_cs_bip.html",
    "href": "examples_cs_bip.html",
    "title": "9  CS-Bipartite Kernel",
    "section": "",
    "text": "Kernel Specification\nThe CS-Bipartite kernel extends the CS (“change-statistic”) kernel to bipartite networks, where nodes belong to two disjoint sets (say Part A and Part B) and edges may only occur across parts (A–B).\nAs in the CS kernel, attachment decisions are driven by ERGM-style change statistics, rather than by degree weighting.\nAt each event time \\(t\\):\n\nA random number of new nodes arrives: \\[\nM_t \\sim \\text{Poisson}(\\lambda_{\\text{node}}),\n\\] where \\(\\lambda_{\\text{node}}\\) is controlled by node_lambda.\nEach arriving node is assigned to one of the two bipartite parts (according to the internal sampling mechanism in the simulator).\nLet \\(V_A(t^-)\\) and \\(V_B(t^-)\\) be the existing nodes in Parts A and B immediately before time \\(t\\). Let \\(N_A(t)\\) and \\(N_B(t)\\) be the sets of new nodes arriving into Parts A and B at time \\(t\\).\n\nThe candidate edge set consists of all possible cross-part new–old edges: \\[\n\\{(u, v): u \\in N_A(t),\\, v \\in V_B(t^-)\\}\n\\;\\cup\\;\n\\{(u, v): u \\in N_B(t),\\, v \\in V_A(t^-)\\}.\n\\]\nOptionally, the candidate set may be truncated (via the truncation argument) to reduce computational cost by limiting how many old nodes each new node is allowed to consider.\nFor each candidate edge \\((u,v)\\), a vector of bipartite change statistics \\[\nC_{uv}(t)\n\\] is computed from the current bipartite network using the user-specified ERGM-style formula (via computeChangeStats()).\nThese are converted into baseline edge probabilities using a logistic link: \\[\np^{(0)}_{uv}(t) = \\text{logit}^{-1}\\!\\left(C_{uv}(t)^\\top \\theta\\right).\n\\]\nAs in the other kernels, an aging / recency adjustment is then applied to down-weight older target nodes: \\[\np_{uv}(t) = p^{(0)}_{uv}(t)\\,\\exp\\!\\big(-\\beta_{\\text{edges}}\\cdot \\text{age}_v(t)\\big),\n\\] where \\(\\text{age}_v(t) = t - t_v\\) is computed from the stored node arrival time.\nEach candidate edge is then treated as an independent Bernoulli trial, so the mark probability is a product of Bernoulli terms over the bipartite candidate edge set.\n\n\n\nData Expectations\nTo use the CS-Bipartite kernel, your observed events must represent a bipartite growth process, meaning:\n\nEvery node belongs to exactly one of two parts (A or B).\nEach event time may introduce zero or more new nodes.\nAny edges observed at an event must connect a new node to an already-existing node in the opposite part.\n\nIn particular, the current CS-Bipartite implementation assumes:\n\nNo within-part edges (no A–A or B–B edges).\nNo old–old edges (edges cannot form between two already-existing nodes).\nNo new–new edges (edges cannot form between two nodes arriving at the same event time).\nNo self-loops, and no duplicate edges within a single event.\n\nIf your data contains cross-part edges forming between two already-existing nodes (e.g. repeated interactions between the same two agents over time), then the CS-Bipartite kernel is not an appropriate mark model without extending the mark space / PMF.\n\n\n\nSimulation\nSimulate CS data.\n\n\n\n\nset.seed(1)\n\ntime &lt;- 10\nparams_cs_bip_true &lt;- list(\n  mu = 2,\n  K = 0.5,\n  beta = 2,\n  beta_edges = 0.5,\n  lambda_new = 2,\n  # CS_edges = -2.5,\n  # CS_triangles = 0.001,\n  CS_star.2 = -1,\n  CS_star.3 = -3\n)\n\nsim &lt;- sim_hawkesNet(\n  params = params_cs_bip_true,\n  T_end = time,\n  mark_type = \"cs_bip\",\n  # formula_rhs = \"edges + triangles() + star(c(2,3))\",\n  formula_rhs = \"star(c(2,3))\"\n)\n\n[1] \"Simulation took 0.3 seconds\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModel fitting\nFit CS data.\n\n\n\n\n\n\nTip\n\n\n\nMake sure to specify the transformation setting for the CS parameters.\nIdeally will default to correct value, but want to discuss how we are implementing the arguments, because lowk I like the old way of passing CS_params better.\n\n\n\nparams_cs_bip_init &lt;- list(\n  mu = 3,\n  K = 1,\n  beta = 1,\n  beta_edges = 1,\n  lambda_new = 5,\n  # CS_edges = -2.5,\n  # CS_triangles = 0.001,\n  CS_star.2 = 0,\n  CS_star.3 = 0\n)\n\nfit &lt;- fit_hawkesNet(\n      ev = sim$ev,\n      params_init = params_cs_bip_init,\n      mark_type = \"cs_bip\",\n      transform = list(CS_star.2 = \"none\", CS_star.3 = \"none\"),\n      formula_rhs = \"star(c(2,3))\"\n    )\n\n[1] \"Fitting took 1.08 seconds\"\n\n\nParameter values on the fitted scale:\n\nunlist(fit$par)\n\n        mu          K       beta beta_edges lambda_new  CS_star.2  CS_star.3 \n 2.5895072  1.1255554 14.5240853  0.3912574  1.7407322 -1.6274125  1.1715270 \n\n\n\n\n\n\n\n\nNote\n\n\n\nEstimates don’t look great @_@\n\n\nParameter values on the transformed scale:\n\nfit$fit$par\n\n        mu          K       beta beta_edges lambda_new  CS_star.2  CS_star.3 \n 0.9514676  0.1182766  2.6758083 -0.9383895  0.5543058 -1.6274125  1.1715270 \n\n\n\n\n\n\n\n\nSee the simulation study results for the CS-BIP kernel here.",
    "crumbs": [
      "Kernels & Examples",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>CS-Bipartite Kernel</span>"
    ]
  },
  {
    "objectID": "custom_pmf.html",
    "href": "custom_pmf.html",
    "title": "10  Custom Kernel PMF",
    "section": "",
    "text": "If you want to add your own custom kernel PMF, I put together a rough “skeleton”.\nI will eventually add some custom-kernel tests to validate whether a new kernel is truly a PMF.\nOnce you’ve written it, you just need to update the likelihood function, see below.\n\n#' Template: log PMF for a mark kernel (one event)\n#'\n#' This is a minimal skeleton for implementing a custom mark kernel. A mark\n#' kernel assigns a probability to the observed edge set for a single event at\n#' time `t_k`, conditional on the pre-event network `net` and the event mark\n#' (`new_nodes`, `new_edges`).\n#'\n#' @param net network object, the current network at time t_k\n#' @param new_nodes data.frame with at least column \"id\". Any additional\n#'                  columns will be treated as vertex attributes.\n#' @param new_edges data.frame with at least columns \"i\" and \"j\". Any additional\n#'                  columns will be treated as edge attributes.\n#' @param t_k numeric scalar, the event timestamp\n#' @param params Named list of model parameters (kernel-specific, any others will be \n#'                  ignored).\n#' @param ... Optional kernel-specific arguments (e.g. tuning constants, caches).\n#'\n#' @return A list with:\n#' \\describe{\n#'   \\item{logp}{Scalar log probability of observing `new_edges` (and any other\n#'   mark components) at this event.}\n#'   \\item{edge_probs}{Named numeric vector (or matrix) of attachment\n#'   probabilities for eligible targets. This is returned for debugging /\n#'   diagnostics and may be `NULL` if not meaningful for the kernel.}\n#'   \\item{model_cache}{Optional updated cache object (useful for expensive mark\n#'   models). Include only if you accept/use a cache via `...`.}\n#' }\n#'\n#' @examples\n#' # See log_pmf_ba() for a working implementation.\ncustom_pmf &lt;- function(\n    net,\n    new_nodes,\n    new_edges,\n    t_k,\n    params,\n    ...\n) {\n  stopifnot(inherits(net, \"network\"))\n  stopifnot(length(t_k) == 1L, is.numeric(t_k), is.finite(t_k))\n\n  # Validate your input here, eg:\n  #     - check parameter values are appropriate1\n  #     - check new_nodes and new_edges are possible under the kernel specs\n  # I think it would be hygiene to create a separate \"validate_custom...()\"\n  # but you could just throw it all in here.\n\n  # Alter these to include your expected columns\n  stopifnot(is.data.frame(new_edges), all(c(\"i\", \"j\") %in% names(new_edges))) \n  stopifnot(is.data.frame(new_nodes), all(c(\"id\") %in% names(new_nodes))) \n\n  # Next I would cover your edge cases & compute edge-candidates, e.g\n  #     - There are no existing nodes in the network\n  #     - There are existing nodes, but no elgible edge-candidates\n\n  # And then finally, compute the actual edge probabilities\n  edge_probs &lt;- calculate_custom_edge_probs(net, t_k, params)\n\n  # Placeholder\n  logp &lt;- NA_real_\n\n  return(\n    list(\n      logp = as.numeric(logp),\n      edge_probs = edge_probs\n      )\n    )\n}\n\nAnd updating the likelihood function:\n\n  #...\n  event_times &lt;- events$times$t\n  if (length(event_times) == 0L) return(0)\n\n  if (is.null(T_end)) T_end &lt;- max(event_times)\n  if (T_end &lt; max(event_times)) stop(\"T_end must be &gt;= max event time\")\n\n  # Mark kernel dispatch\n  if (mark_type == \"ba\") {\n    mark_logpmf &lt;- log_pmf_ba\n  } else if (mark_type == \"ba_bip\") {\n    mark_logpmf &lt;- log_pmf_ba_bip\n  } else if (mark_type == \"cs\") {\n    mark_logpmf &lt;- log_pmf_cs\n  } else if (mark_type == \"YOUR CUSTOM PMF GOES HERE\") { # ADD THESE LINES\n    mark_logpmf &lt;- YOUR_CUSTOM_PMF_FUNCTION # ADD THESE LINES\n  } else {\n    stop(\"mark_type must be one of 'ba', 'cs', 'ba_bip', 'YOUR_CUSTOM_PMF'\")\n  }\n  # ...\n\n\n\n\n\n\n\nNote\n\n\n\nYes definitely a better way to do this, just a temporary solution for now.",
    "crumbs": [
      "Writing Custom Kernels",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Custom Kernel PMF</span>"
    ]
  },
  {
    "objectID": "custom_sim.html",
    "href": "custom_sim.html",
    "title": "11  Custom Kernel Simulation",
    "section": "",
    "text": "Work in progress, template will be done soon.",
    "crumbs": [
      "Writing Custom Kernels",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Custom Kernel Simulation</span>"
    ]
  },
  {
    "objectID": "crime_data.html",
    "href": "crime_data.html",
    "title": "12  Crime data",
    "section": "",
    "text": "12.1 BA-Bipartite Network Specification\nSo we have some crime data. The data will not be uploaded, I will just include the code here you can copy and paste to run the data cleaning / model fitting yourself.\nTo briefly describe it\nRecall under the BA-Bipartite network specification we are assuming that marks are structured in the following way:\nUnder this specification, perp-perp edges are not allowed to exist (is this correct?). Hence we can ignore the edges present in the perps.df (we will revisit when trying different model specs).",
    "crumbs": [
      "Sim studies",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Crime data</span>"
    ]
  },
  {
    "objectID": "crime_data.html#ba-bipartite-network-specification",
    "href": "crime_data.html#ba-bipartite-network-specification",
    "title": "12  Crime data",
    "section": "",
    "text": "Nodes have two possible classifications - event and perp.\nEach mark consists of exactly 1 new event node arriving, which connects to old perp nodes according to the same degree-based weighting as the BA kernel.\nThe number of perp nodes is distributed Poisson(lambda_new)\n\n\n\n12.1.1 Data prep\nNow, looking at the perps.df data:\n\nsummary(as.numeric(perps$person_id))\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n      5  426537  863430  868561 1307976 1742898 \n\n\nIt looks like the person_id’s stretch all the way from 5 to 1742898. We will just treat these as node ID’s. And in order to prevent any clashes, we will just prepend “event_” on to the event_id to use as the node ID’s of the event nodes.\nFirst converting to long format.\n\nlibrary(tidyr)\nlibrary(dplyr)\n\n# Love how easy this is\nlong_df &lt;- events %&gt;%\n  unnest(people) %&gt;%\n  rename(person = people)\n\nNow need to make sure the names don’t clash as mentioned above (will prepend “perp_” to the perp ID’s aswell just for consistency):\n\nedges &lt;- long_df %&gt;% \n  mutate(\n    event_id = paste0(\"event_\", event_id),\n    person = paste0(\"perp_\", person)\n    ) %&gt;% \n  rename(\n    i = event_id, # Doesn't matter what order we choose i/j\n    j = person,\n    time = diff_date\n  ) %&gt;% \n  select(i, j, time) %&gt;% \n  distinct() %&gt;%  # The way the original data set was constructed, we end up with\n  filter(time &lt; 5)                  # two identical rows per edge sometimes\n\n# Only considering a small sub net for example \n\nLastly, we need to make sure we include the perp-event node classification.\nThis is easier if we use make_events() first, as it will automatically generate a nodes data frame, and then we can just add a column to this.\n\n\n\n\n\n\nNote\n\n\n\nNot sure if I like this manipulation after-the-fact. Wondering how you guys prepared your data.\n\n\n\nev &lt;- make_events(edges = edges)\n\nLooks like 14000-ish events, 27000-ish node arrivals, and 19000-ish edges.\nNow just add a “role” column to ev$nodes:\n\nev$nodes$role &lt;- ifelse(\n  grepl(\"event\", ev$nodes$id),\n  \"event\",\n  \"perp\"\n)\n\nAnd we are good to fit.\n\n\n12.1.2 Model fitting\nOnly gonna consider a SMALL time window, just trying to demonstrate here.\n\nsum(ev$times &lt; 5)\n\n[1] 147\n\n\nWe’ll set T_end = 5.\n\nparams_bip_init &lt;- list(\n  mu = 1,\n  K = 1,\n  beta = 1,\n  beta_edges = 1,\n  lambda_new = 3.5\n)\n\nfit &lt;- fit_hawkesNet(\n      ev = ev,\n      params_init = params_bip_init,\n      mark_type = \"ba_bip\",\n      debug = T\n    )",
    "crumbs": [
      "Sim studies",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Crime data</span>"
    ]
  },
  {
    "objectID": "ba_study.html",
    "href": "ba_study.html",
    "title": "14  BA Sim Study",
    "section": "",
    "text": "14.1 Quick summary\nThis page summarizes the BA kernel simulation study results saved as per-replicate .rds files under:\nEach replicate contains truth, estimates, counts, and runtimes (see str(ba_rep_003)).\ntab &lt;- summary_table(df)\ntab\n\n# A tibble: 6 × 7\n  T_end     n keep_rate n_events_mean n_events_sd sim_s_mean fit_s_mean\n  &lt;dbl&gt; &lt;int&gt;     &lt;dbl&gt;         &lt;dbl&gt;       &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1     5   350     0.954          81.5        14.6      0.297       1.46\n2    10   350     0.963         180.         24.3      0.530       2.30\n3    25   350     0.994         476.         41.2      1.88        6.46\n4    50   350     0.997         975.         62.8      5.86       16.2 \n5    75   350     0.997        1476.         79.5     12.4        35.3 \n6   100   350     0.997        1973.         94.2     19.4        50.7",
    "crumbs": [
      "Sim studies",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>BA Sim Study</span>"
    ]
  },
  {
    "objectID": "ba_study.html#cap-exceeded-replicates",
    "href": "ba_study.html#cap-exceeded-replicates",
    "title": "14  BA Sim Study",
    "section": "14.2 Cap-Exceeded Replicates",
    "text": "14.2 Cap-Exceeded Replicates\nThere were a few replicates which “exploded”, and ended up with unrealistic estimates of K & beta. I decided to just filter these out, as it was making the plots unreadable.\nChose to filter out any \\(K &gt; 20\\), \\(\\beta &gt; 20\\) (arbitrarily).\n\ndf %&gt;%\n  summarise(\n    n_total = n(),\n    n_keep  = sum(keep, na.rm = TRUE),\n    n_dropped_caps = sum(drop_reason == \"cap_exceeded\", na.rm = TRUE)\n  )\n\n# A tibble: 1 × 3\n  n_total n_keep n_dropped_caps\n    &lt;int&gt;  &lt;int&gt;          &lt;int&gt;\n1    2100   2066             34\n\ndf_keep &lt;- df %&gt;% filter(keep)",
    "crumbs": [
      "Sim studies",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>BA Sim Study</span>"
    ]
  },
  {
    "objectID": "ba_study.html#parameter-estimates-vs-t_end",
    "href": "ba_study.html#parameter-estimates-vs-t_end",
    "title": "14  BA Sim Study",
    "section": "14.3 Parameter estimates vs T_end",
    "text": "14.3 Parameter estimates vs T_end\nDashed line = true value.\n\nplot_estimates_vs_T(df, keep_only = TRUE)\n\n\n\n\n\n\n\n\nLog scale:\n\nplot_estimates_vs_T(df, keep_only = TRUE, log_scale = TRUE)",
    "crumbs": [
      "Sim studies",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>BA Sim Study</span>"
    ]
  },
  {
    "objectID": "ba_study.html#counts-vs-t_end",
    "href": "ba_study.html#counts-vs-t_end",
    "title": "14  BA Sim Study",
    "section": "14.4 Counts vs T_end",
    "text": "14.4 Counts vs T_end\n\nplot_counts_vs_T(df)",
    "crumbs": [
      "Sim studies",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>BA Sim Study</span>"
    ]
  },
  {
    "objectID": "ba_study.html#keep-rate-vs-t_end",
    "href": "ba_study.html#keep-rate-vs-t_end",
    "title": "14  BA Sim Study",
    "section": "14.5 Keep rate vs T_end",
    "text": "14.5 Keep rate vs T_end\n\nplot_keep_rate_vs_T(df)",
    "crumbs": [
      "Sim studies",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>BA Sim Study</span>"
    ]
  },
  {
    "objectID": "ba_study.html#rmse-decay-vs-t_end",
    "href": "ba_study.html#rmse-decay-vs-t_end",
    "title": "14  BA Sim Study",
    "section": "14.6 RMSE decay vs T_end",
    "text": "14.6 RMSE decay vs T_end\n\nplot_rmse_vs_T(df)",
    "crumbs": [
      "Sim studies",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>BA Sim Study</span>"
    ]
  },
  {
    "objectID": "ba_study.html#runtime-vs-t_end",
    "href": "ba_study.html#runtime-vs-t_end",
    "title": "14  BA Sim Study",
    "section": "14.7 Runtime vs T_end",
    "text": "14.7 Runtime vs T_end\n\nplot_runtime_vs_T(df)",
    "crumbs": [
      "Sim studies",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>BA Sim Study</span>"
    ]
  }
]