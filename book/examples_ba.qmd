{{< include _setup.qmd >}}

# BA Kernel

### Kernel Specification {.unnumbered}

Each mark consists of exactly one new node, which has edges from that new node 
to older nodes according to a normalized degree-based weighting.

Will update this later.

### Simulation {.unnumbered}

Simulate BA data:

<div class="vcenter-cols">
::: {.columns}
::: {.column width="40%"}

```{r}
set.seed(1)

time <- 50
params_ba_true <- list(
  mu = 0.5,
  K = 0.5,
  beta = 0.5,
  beta_edges = 2
)

sim <- sim_hawkesNet(
  params = params_ba_true,
  T_end = time,
  mark_type = "ba"
)
```
:::
::: {.column width="60%"}

```{r fig.width=8, fig.height=8, out.width="100%", echo = FALSE}
op <- par(no.readonly = TRUE)
on.exit(par(op), add = TRUE)

par(mar = c(1,1,1,1), xaxs = "i", yaxs = "i")
plot(sim$net)
```
:::
:::
</div>

### Model fitting {.unnumbered}

Fit BA data.

```{r}
params_ba_init <- list(
  mu = 1,
  K = 1,
  beta = 1,
  beta_edges = 1
)

fit <- fit_hawkesNet(
      ev = sim$ev,
      params_init = params_ba_init,
      mark_type = "ba"
    )
```

Parameter values on the fitted scale:

```{r}
unlist(fit$par)
```

Not too bad.

And, we can also grab parameter values on the transformed scale:

```{r}
# Yes I know this is a jank way to structure it right now, will fix
fit$fit$par
```

::: {.callout-note collapse="true"}
## See the simulation study results for the BA kernel here.
:::










