{
  "hash": "3345417e9dda1d1f618c8dd11f51e8b8",
  "result": {
    "engine": "knitr",
    "markdown": "\n\n```{=html}\n<style>\n.vcenter-cols .columns {\n  display: flex;\n  align-items: center;\n  gap: 0.75rem;\n}\n.vcenter-cols .columns .column {\n  flex: 1 1 0;\n}\n</style>\n```\n\n\n# Events\n\n`hawkesNet` is **events-first**. Instead of converting your data into a `network`\nobject up-front, you provide **node arrivals** and **edge arrivals** as data\nframes, then call `make_events()` to convert them into the internal `events`\nrepresentation used by simulation and fitting.\n\n## Input data frames {.unnumbered}\n\nAs stated, the two inputs are an `edges` and a `nodes` data frame. \n\n::: {.callout-note}\nThe `nodes` data frame is not required. Node arrival times can be inferred\nfrom the edge alone (make sure `allow_implicit_births = TRUE` when using \n`make_events()`). However, if you only pass `edges`, you **cannot** represent \nedgeless node arrivals, as the node only exists when it first appears in an edge.\n:::\n\n### `edges` {.unnumbered}\n\n| Column | Type | Meaning | Notes |\n|---|---|---|---|\n| `i` | character / integer | Tail/endpoint node id | Together with `j` identifies an edge between two nodes. |\n| `j` | character / integer | Head/endpoint node id | Current `hawkesNet` kernels treat edges as **undirected** (order doesn’t matter). |\n| `time` | numeric | Edge arrival time | Must be $\\ge$ both endpoint birth times in `nodes` (if provided). |\n| `...` | any | Extra edge attributes | Carried through as edge attributes in the underlying network during fitting. |\n\n\n### `nodes` {.unnumbered}\n\n| Column | Type | Meaning | Notes |\n|---|---|---|---|\n| `id` | character / integer | Node identifier | Must be unique within `nodes`. IDs used in `edges$i`/`edges$j` must match these. |\n| `time` | numeric | Node birth/arrival time | Can be continuous or discrete. Must be comparable to `edges$time`. |\n| `role` (optional) | character | Node role/type <br> (e.g. `\"event\"`, `\"perp\"`) | Required for bipartite kernels (e.g. `*_bip`) if your mark model distinguishes node types. |\n| `...` | any | Extra node attributes | Carried through as vertex attributes in the underlying network during fitting. |\n\n\n## Creating events objects {.unnumbered}\n\n### `make_events()` {.unnumbered}\n\nYou can create events objects used for fitting by using the `make_events()` function.\n\n| Argument | What it is | What it does |\n|---|---|---|\n| `nodes` | data frame (optional) | Node arrivals (`id`, `time`, …). If omitted, births can be inferred from `edges` (see below). |\n| `edges` | data frame (optional) | Edge arrivals (`i`, `j`, `time`, …). |\n| `allow_implicit_birth` | logical | If `TRUE` and `nodes` is not supplied, infer node birth time as the first time the id appears in `edges`. |\n| `...` | optional | Package may expose additional validation/behaviour flags (kept here to avoid duplicating implementation details in the docs). |\n\n### Return value {.unnumbered}\n\nAn `events` object is a list with three data frames:\n\n| Component | Columns | Meaning |\n|---|---|---|\n| `ev$times` | `event_id`, `t` | Unique sorted times used as event indices. |\n| `ev$nodes` | `event_id`, `id`, … | Node arrivals mapped onto `event_id`. |\n| `ev$edges` | `event_id`, `i`, `j`, … | Edge arrivals mapped onto `event_id`. |\n\n## Helpers {.unnumbered}\n\nThere are a number of helpers included in the package to make working with the \n`events` objects easier:\n\n- `create_net_from_events(ev)` → Create an `events` object from an `network` object.\n- `create_events_from_net(net)` → Create an `network` object from an `events` object.\n- `nodes_by_event(ev)` → list of node-arrival data frames (one per `event_id`)\n- `edges_by_event(ev)` → list of edge-arrival data frames (one per `event_id`)\n\nSee the actual docs (eg. `?hawkesNet::create_net_from_events`) for more \ninformation on these.\n\n## Examples {.unnumbered}\n\n### Standard {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnodes <- data.frame(\n  id   = c(\"1\", \"2\", \"3\"),\n  time = c(0, 1, 2)\n)\nedges <- data.frame(\n  i    = c(\"1\", \"1\"),\n  j    = c(\"2\", \"3\"),\n  time = c(1, 2)\n)\n\nev <- make_events(nodes = nodes, edges = edges)\n```\n:::\n\n\n### Implicit births from edges {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nedges_example <- data.frame(\n  i    = c(\"1\", \"1\"),\n  j    = c(\"2\", \"3\"),\n  time = c(1, 2)\n)\n\nevents_from_edges <- make_events(edges = edges_example, allow_implicit_birth = TRUE)\n```\n:::\n\n\n### Node & edge attributes {.unnumbered}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnodes <- data.frame(\n  id   = c(\"1\", \"2\", \"3\"),\n  time = c(0, 1, 2),\n  role = c(\"event\", \"perp\", \"perp\")\n)\nedges <- data.frame(\n  i    = c(\"1\", \"1\"),\n  j    = c(\"2\", \"3\"),\n  time = c(1, 2),\n  attribute = c(\"strong\", \"weak\")\n)\n\nev <- make_events(nodes = nodes, edges = edges)\n\nev$nodes\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  event_id id  role\n1        1  1 event\n2        2  2  perp\n3        3  3  perp\n```\n\n\n:::\n\n```{.r .cell-code}\nev$edges\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  event_id i j attribute\n1        2 1 2    strong\n2        3 1 3      weak\n```\n\n\n:::\n:::\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}