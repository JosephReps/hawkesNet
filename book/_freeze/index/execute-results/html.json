{
  "hash": "8377a879b1f99c9d0f016566c22c82af",
  "result": {
    "engine": "knitr",
    "markdown": "<style>\n/* --- Hero block styling --- */\n.net-hero-wrap{\n  max-width: 650px;\n  margin: 1.2rem auto 0.6rem auto;\n  padding: 0;\n}\n\n.observablehq canvas,\n#net-hero{\n  width: 650px;\n  height: 550px;\n  max-width: 100%;\n  margin: 0 auto;\n  display: block;\n}\n\n/* --- Caption under canvas --- */\n.net-hero-caption{\n  max-width: 650px;\n  margin: 0.4rem auto 1.4rem auto;\n  font-size: 0.85rem;\n  line-height: 1.4;\n  color: #9aa0a6;\n  text-align: center;\n}\n\n/* --- Buttons row --- */\n.net-buttons{\n  display: flex;\n  justify-content: start;\n  gap: 0.55rem;\n  flex-wrap: wrap;\n  margin: -1rem 0 2rem 0;\n}\n\n.net-btn{\n  display: inline-flex;\n  align-items: center;\n  gap: 0.45rem;\n\n  padding: 0.36rem 0.85rem;\n  border-radius: 8px;\n\n  font-size: 0.88rem;\n  font-weight: 600;\n  letter-spacing: -0.01em;\n\n  text-decoration: none;\n  line-height: 1;\n\n  color: rgba(10,15,20,0.92);\n\n  background: transparent;\n  border: 1px solid rgba(255,255,255,0.22);\n\n  box-shadow: 0 2px 7px rgba(0,0,0,0.18);\n\n  transition: background 0.15s ease,\n              border-color 0.15s ease,\n              box-shadow 0.15s ease,\n              transform 0.12s ease;\n}\n\n.net-btn:hover{\n  background: rgba(70,170,255,0.18);\n  border-color: rgba(70,170,255,0.90);\n  color: rgba(10,15,20,0.92);\n}\n</style>\n\n<div class=\"net-buttons\">\n  <a class=\"net-btn secondary\" href=\"#installation\">ðŸ“¦ Installation</a>\n  <a class=\"net-btn primary\" href=\"examples_ba.html\">ðŸš€ Skip to Examples</a>\n</div>\n\n<div class=\"net-hero-wrap\">\n  <canvas id=\"net-hero\" width=\"650\" height=\"550\" aria-label=\"Interactive evolving network\"></canvas>\n</div>\n\n<div class=\"net-hero-caption\">\n  Interactive network visualisation. (Soon: real-time BA / CS simulation toggle.)\n</div>\n\n# Preface {.unnumbered}\n\n`hawkesNet` is an R package for fitting self-exciting network growth models.\nIt is designed to support simulation studies, model comparison, and scalable\ninference on dynamic networks.\n\nThis e-book acts as both a guide to using the package, as well as a quick way to\nparse through documentation.\n\n## Installation {#installation}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"devtools\")\ndevtools::install_github(\"JosephReps/hawkesNet\")\n```\n:::\n\n\n<!-- This is the interactive network code -->\n<!-- Straight from vibe-coding hell -->\n\n<script type=\"module\">\nimport * as d3 from \"https://cdn.jsdelivr.net/npm/d3@7/+esm\";\n\nconst canvas = document.getElementById(\"net-hero\");\nconst ctx = canvas.getContext(\"2d\");\n\nconst width  = canvas.width;\nconst height = canvas.height;\n\nconst N = 100;\nconst M_TARGET = 170;\n\nconst cx = width / 2;\nconst cy = height / 2;\nconst R  = Math.min(width, height) / 2 - 14;\n\nconst ERASE_RADIUS = 7;\n\n// smoother edge growth\nconst EDGE_FADE_MS = 1100;      // was 700\nconst REGROW_INTERVAL_MS = 40;\nconst ERASE_COOLDOWN_MS = 10;\n\nconst randInt = (n) => (Math.random() * n) | 0;\nconst edgeKey = (a,b) => (a < b) ? `${a}-${b}` : `${b}-${a}`;\n\n// --- Theme colors ---\nfunction rgbaFromCssVar(varName, fallbackHex, a){\n  const css = getComputedStyle(document.documentElement);\n  const col = (css.getPropertyValue(varName) || fallbackHex).trim();\n  const m = col.match(/^#([0-9a-f]{6})$/i);\n  if (!m) return `rgba(17,17,17,${a})`;\n  const hex = m[1];\n  const R = parseInt(hex.slice(0,2), 16);\n  const G = parseInt(hex.slice(2,4), 16);\n  const B = parseInt(hex.slice(4,6), 16);\n  return `rgba(${R},${G},${B},${a})`;\n}\nconst EDGE_BASE   = rgbaFromCssVar(\"--bs-body-color\", \"#111111\", 0.18);\nconst NODE_FILL   = rgbaFromCssVar(\"--bs-body-color\", \"#111111\", 0.85);\nconst RING_STROKE = rgbaFromCssVar(\"--bs-border-color\", \"#cccccc\", 0.65);\n\n// --- Nodes ---\nconst nodes = Array.from({ length: N }, (_, i) => ({ id: i }));\n\n// --- Edges ---\nconst edgeSet = new Set();\nlet links = [];\n\nfunction addEdge(a, b, born = performance.now()){\n  if (a === b) return false;\n  const key = edgeKey(a,b);\n  if (edgeSet.has(key)) return false;\n  edgeSet.add(key);\n  links.push({ source: a, target: b, born });\n  return true;\n}\n\nfunction removeEdgeByIndex(i){\n  const l = links[i];\n  const s = (typeof l.source === \"object\") ? l.source.id : l.source;\n  const t = (typeof l.target === \"object\") ? l.target.id : l.target;\n  edgeSet.delete(edgeKey(s,t));\n  links[i] = null;\n}\n\n// Initial edges\nwhile (links.length < M_TARGET){\n  const a = randInt(N);\n  let b = randInt(N);\n  if (b === a) b = (b + 1) % N;\n  addEdge(a,b);\n}\n\n// --- Forces (FR-ish) ---\nconst sim = d3.forceSimulation(nodes)\n  .force(\"charge\", d3.forceManyBody().strength(-65))\n  .force(\"link\", d3.forceLink(links).id(d => d.id)\n    .distance(16)\n    .strength(0.32))\n  .force(\"center\", d3.forceCenter(cx, cy))\n  .force(\"collision\", d3.forceCollide(3))\n  .alpha(1);\n\nconst linkForce = sim.force(\"link\");\n\n// Boundary push (start earlier, stronger)\nfunction forceBoundaryPush(pushStrength = 0.85, startFrac = 0.60){\n  let _nodes;\n  const startR = R * startFrac;\n  function force(alpha){\n    const s = pushStrength * alpha;\n    for (const n of _nodes){\n      const dx = n.x - cx;\n      const dy = n.y - cy;\n      const d  = Math.hypot(dx, dy);\n      if (d > startR){\n        const t = Math.min(1, (d - startR) / (R - startR)); // 0..1\n        const k = s * t * t;\n        n.vx += (-dx / (d || 1)) * k;\n        n.vy += (-dy / (d || 1)) * k;\n      }\n    }\n  }\n  force.initialize = (ns) => { _nodes = ns; };\n  return force;\n}\nsim.force(\"boundary\", forceBoundaryPush(0.85, 0.60));\n\n// Hard clamp + velocity reflection to prevent rim-sticking\nsim.on(\"tick\", () => {\n  for (const n of nodes){\n    const dx = n.x - cx;\n    const dy = n.y - cy;\n    const d  = Math.hypot(dx, dy);\n\n    if (d > R){\n      // project back inside\n      const ux = dx / (d || 1);\n      const uy = dy / (d || 1);\n      n.x = cx + ux * (R - 0.8);\n      n.y = cy + uy * (R - 0.8);\n\n      // reflect outward velocity component + damp (key fix)\n      const vdot = n.vx * ux + n.vy * uy; // component along outward normal\n      if (vdot > 0){\n        n.vx -= 1.6 * vdot * ux;\n        n.vy -= 1.6 * vdot * uy;\n      }\n      n.vx *= 0.85;\n      n.vy *= 0.85;\n    }\n  }\n});\n\n// Keep evolving\nsetInterval(() => {\n  sim.alpha(Math.max(sim.alpha(), 0.10)).restart();\n}, 1200);\n\n// --- Mouse erase ---\nlet mouse = { x: -1e9, y: -1e9, inside: false };\nlet eraseCooldown = 0;\n\nfunction toCanvasXY(e){\n  const rect = canvas.getBoundingClientRect();\n  const sx = width / rect.width;\n  const sy = height / rect.height;\n  return {\n    x: (e.clientX - rect.left) * sx,\n    y: (e.clientY - rect.top) * sy\n  };\n}\n\ncanvas.addEventListener(\"mousemove\", (e) => {\n  const p = toCanvasXY(e);\n  mouse.x = p.x; mouse.y = p.y;\n\n  const dx = mouse.x - cx;\n  const dy = mouse.y - cy;\n  mouse.inside = (dx*dx + dy*dy) <= R*R;\n\n  if (mouse.inside) eraseTouchedEdges();\n});\n\ncanvas.addEventListener(\"mouseleave\", () => {\n  mouse.x = -1e9; mouse.y = -1e9; mouse.inside = false;\n});\n\nfunction distPointToSeg(px, py, ax, ay, bx, by){\n  const abx = bx - ax, aby = by - ay;\n  const apx = px - ax, apy = py - ay;\n  const ab2 = abx*abx + aby*aby;\n  if (ab2 === 0) return Math.hypot(px-ax, py-ay);\n  let t = (apx*abx + apy*aby) / ab2;\n  t = Math.max(0, Math.min(1, t));\n  return Math.hypot(px-(ax+t*abx), py-(ay+t*aby));\n}\n\nfunction eraseTouchedEdges(){\n  const now = performance.now();\n  if (now < eraseCooldown) return;\n  eraseCooldown = now + ERASE_COOLDOWN_MS;\n\n  const pr = ERASE_RADIUS;\n  let removed = 0;\n\n  for (let i = 0; i < links.length; i++){\n    const l = links[i];\n    if (!l) continue;\n\n    const s = (typeof l.source === \"object\") ? l.source : nodes[l.source];\n    const t = (typeof l.target === \"object\") ? l.target : nodes[l.target];\n\n    const minx = Math.min(s.x, t.x) - pr, maxx = Math.max(s.x, t.x) + pr;\n    const miny = Math.min(s.y, t.y) - pr, maxy = Math.max(s.y, t.y) + pr;\n    if (mouse.x < minx || mouse.x > maxx || mouse.y < miny || mouse.y > maxy) continue;\n\n    if (distPointToSeg(mouse.x, mouse.y, s.x, s.y, t.x, t.y) <= pr){\n      removeEdgeByIndex(i);\n      removed++;\n    }\n  }\n\n  if (removed > 0){\n    links = links.filter(Boolean);\n    linkForce.links(links);\n    sim.alpha(0.35).restart();\n  }\n}\n\n// --- FAST autonomous regrowth (adds edges quickly but looks smooth because of fade/ease) ---\nfunction regrowTick(){\n  const deficit = M_TARGET - links.length;\n  if (deficit <= 0) return;\n\n  let adds = 1;\n  if (deficit > 60) adds = 6;\n  else if (deficit > 30) adds = 4;\n  else if (deficit > 10) adds = 2;\n\n  const now = performance.now();\n  for (let k = 0; k < adds; k++){\n    const a = randInt(N);\n    let b = randInt(N);\n    if (b === a) b = (b + 1) % N;\n    addEdge(a,b, now);\n  }\n\n  linkForce.links(links);\n  sim.alpha(0.22).restart();\n}\nsetInterval(regrowTick, REGROW_INTERVAL_MS);\n\n// --- Smooth easing for edge growth ---\nfunction easeInOut(t){\n  // cubic smoothstep\n  return t * t * (3 - 2 * t);\n}\n\n// --- Render ---\nfunction draw(){\n  ctx.clearRect(0, 0, width, height);\n\n  ctx.save();\n  ctx.beginPath();\n  ctx.arc(cx, cy, R, 0, Math.PI * 2);\n  ctx.clip();\n\n  const now = performance.now();\n\n  // base edges\n  ctx.strokeStyle = EDGE_BASE;\n  ctx.lineWidth = 1;\n  ctx.beginPath();\n  for (const l of links){\n    const s = (typeof l.source === \"object\") ? l.source : nodes[l.source];\n    const t = (typeof l.target === \"object\") ? l.target : nodes[l.target];\n    ctx.moveTo(s.x, s.y);\n    ctx.lineTo(t.x, t.y);\n  }\n  ctx.stroke();\n\n  // new-edge overlay: ease opacity + start slightly thicker but faint\n  for (const l of links){\n    const age = now - (l.born ?? now);\n    if (age >= EDGE_FADE_MS) continue;\n\n    const t = Math.max(0, Math.min(1, age / EDGE_FADE_MS));\n    const a = easeInOut(t);\n\n    // subtle: fade in to a bit above base opacity\n    ctx.strokeStyle = rgbaFromCssVar(\"--bs-body-color\", \"#111111\", 0.34 * a);\n    ctx.lineWidth = 1 + (1 - a) * 1.2; // thicker at birth, settles to 1\n    ctx.beginPath();\n    const s = (typeof l.source === \"object\") ? l.source : nodes[l.source];\n    const tnode = (typeof l.target === \"object\") ? l.target : nodes[l.target];\n    ctx.moveTo(s.x, s.y);\n    ctx.lineTo(tnode.x, tnode.y);\n    ctx.stroke();\n  }\n  ctx.lineWidth = 1;\n\n  // nodes\n  ctx.fillStyle = NODE_FILL;\n  for (const n of nodes){\n    ctx.beginPath();\n    ctx.arc(n.x, n.y, 2.4, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  ctx.restore();\n\n  // boundary\n  ctx.strokeStyle = RING_STROKE;\n  ctx.lineWidth = 1;\n  ctx.beginPath();\n  ctx.arc(cx, cy, R + 0.5, 0, Math.PI * 2);\n  ctx.stroke();\n\n  requestAnimationFrame(draw);\n}\ndraw();\n</script>\n\n\n\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}