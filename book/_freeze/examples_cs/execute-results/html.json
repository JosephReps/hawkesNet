{
  "hash": "5de261f967346336681c00dec4702d2b",
  "result": {
    "engine": "knitr",
    "markdown": "\n\n```{=html}\n<style>\n.vcenter-cols .columns {\n  display: flex;\n  align-items: center;\n  gap: 0.75rem;\n}\n.vcenter-cols .columns .column {\n  flex: 1 1 0;\n}\n</style>\n```\n\n\n# CS Kernel\n\n:::callout-warning\nMy CS specification does NOT allow for marks to contain edges between two old nodes.\n:::\n\n### Kernel Specification {.unnumbered}\n\nThe CS (“change-statistic”) kernel is also a **new-node attachment** model, but instead of choosing attachment targets using degree weights (as in BA), it uses **ERGM-style change statistics** to score each possible new–old edge.\n\nAt each event time $t$:\n\n- A random number of **new nodes** arrives:\n  $$\n  M_t \\sim \\text{Poisson}(\\lambda_{\\text{node}}),\n  $$\n  (in the code this is `node_lambda`). Optionally, arrivals can be forced to stop after a cutoff time `max_node_time` (in which case $M_t$ must be 0 for $t$ past the cutoff).\n\n- Let $V(t^-)$ be the set of existing (“old”) nodes right before time $t$, and let $N(t)$ be the set of $M_t$ new nodes arriving at time $t$.\n\n- The model defines a **candidate set** of possible edges. In the current implementation, candidate edges are constructed deterministically as\n  $$\n  \\{(u, v): u \\in N(t),\\; v \\in V(t^-)\\},\n  $$\n  with an optional **truncation** that limits each new node to only consider the first `truncation` old nodes (according to the current ordering used internally) (Currently not implemented, argument doesn't do anything but it's not needed).\n\nFor each candidate edge $(u, v)$ (new node $u$ to old node $v$), a vector of change statistics\n$$\nC_{uv}(t)\n$$\nis computed from the current network using the ERNM/ERGM-style specification you provide (via `formula_rhs` / `computeChangeStats()`).\n\nThese statistics are mapped to a baseline attachment probability using a logistic link:\n$$\np^{(0)}_{uv}(t) = \\text{logit}^{-1}\\!\\left(C_{uv}(t)^\\top \\theta\\right).\n$$\n\nFinally, an **aging / recency** adjustment is applied to down-weight older target nodes:\n$$\np_{uv}(t) = p^{(0)}_{uv}(t)\\,\\exp\\!\\big(-\\beta_{\\text{edges}}\\cdot \\text{age}_v(t)\\big),\n$$\nwhere $\\text{age}_v(t) = t - t_v$ and $t_v$ is the stored node arrival time. (In the implementation, probabilities are also clipped away from 0/1 for numerical stability.)\n\nUnder this mark model, each candidate edge is treated as an independent Bernoulli trial, so the probability of observing a particular set of edges at time $t$ is a **Bernoulli-product** over the candidate set.\n\n---\n\n### Data Expectations {.unnumbered}\n\nTo use the CS kernel, your events must match the “new nodes arrive + may connect to existing nodes” pattern:\n\n- Each event time can introduce **zero or more new nodes**.\n- Any edges observed at that event must be **between a new node and an old node**.\n\nImportantly (based on the current PMF / validators):\n\n- **Old–old edges are not allowed** (edges between two already-existing nodes).\n- **New–new edges are not allowed**.\n- **Self-loops are not allowed**.\n- Within a single event, you should not repeat the same edge (no duplicates for a given unordered pair).\n\nIf your data includes edges forming between two existing nodes (e.g., repeated interactions/transactions, new ties between old users, etc.), then the current CS mark model is not appropriate without extending the mark space / PMF.\n\n---\n\n### Simulation {.unnumbered}\n\nSimulate CS data.\n\n<div class=\"vcenter-cols\">\n::: {.columns}\n::: {.column width=\"40%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\n\ntime <- 15\nparams_cs_true <- list(\n  mu = 5,\n  K = 0.5,\n  beta = 2,\n  beta_edges = 0.5,\n  node_lambda = 4,\n  # CS_edges = -2.5,\n  # CS_triangles = 0.001,\n  CS_star.2 = -1,\n  CS_star.3 = -3\n)\n\nsim <- sim_hawkesNet(\n  params = params_cs_true,\n  T_end = time,\n  mark_type = \"cs\",\n  # formula_rhs = \"edges + triangles() \n  # + star(c(2,3))\",\n  formula_rhs = \"star(c(2,3))\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Simulation took 0.98 seconds\"\n```\n\n\n:::\n:::\n\n:::\n::: {.column width=\"60%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](examples_cs_files/figure-html/unnamed-chunk-3-1.png){width=100%}\n:::\n:::\n\n:::\n:::\n</div>\n\n### Model fitting {.unnumbered}\n\n\nFit CS data. \n\n:::callout-tip\nMake sure to specify the transformation setting for the CS parameters. \n\nIdeally will default to correct value, but want to discuss how we are implementing\nthe arguments, because lowk I like the old way of passing `CS_params` better.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparams_cs_init <- list(\n  mu = 3,\n  K = 1,\n  beta = 1,\n  beta_edges = 1,\n  node_lambda = 5,\n  # CS_edges = -2.5,\n  # CS_triangles = 0.001,\n  CS_star.2 = 0,\n  CS_star.3 = 0\n)\n\nfit <- fit_hawkesNet(\n      ev = sim$ev,\n      params_init = params_cs_init,\n      mark_type = \"cs\",\n      transform = list(CS_star.2 = \"none\", CS_star.3 = \"none\"),\n      formula_rhs = \"star(c(2,3))\"\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Fitting took 9.72 seconds\"\n```\n\n\n:::\n:::\n\n\nParameter values on the fitted scale:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunlist(fit$par)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         mu           K        beta  beta_edges node_lambda   CS_star.2 \n  4.6384795   0.7236149   3.3119207   0.4046910   4.1888536  -0.9812649 \n  CS_star.3 \n -3.1691266 \n```\n\n\n:::\n:::\n\n\nNotttt baddddd.\n\nParameter values on the transformed scale:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit$fit$par\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         mu           K        beta  beta_edges node_lambda   CS_star.2 \n  1.5343866  -0.3234959   1.1975283  -0.9046315   1.4324271  -0.9812649 \n  CS_star.3 \n -3.1691266 \n```\n\n\n:::\n:::\n\n\n\n\n",
    "supporting": [
      "examples_cs_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}