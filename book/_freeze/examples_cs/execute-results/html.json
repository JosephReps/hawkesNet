{
  "hash": "4b229164b0c5aa2db5689147afe1cdc2",
  "result": {
    "engine": "knitr",
    "markdown": "\n\n\n# CS Examples\n\nSimulate CS data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\n\ntime <- 5\nparams_cs_true <- list(\n  mu = 5,\n  K = 0.5,\n  beta = 2,\n  beta_edges = 0.5,\n  node_lambda = 4,\n  # CS_edges = -2.5,\n  # CS_triangles = 0.001,\n  CS_star.2 = -1,\n  CS_star.3 = -3\n)\n\nsim <- sim_hawkesNet(\n  params = params_cs_true,\n  T_end = time,\n  mark_type = \"cs\",\n  # formula_rhs = \"edges + triangles() + star(c(2,3))\",\n  formula_rhs = \"star(c(2,3))\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Simulation took 0.39 seconds\"\n```\n\n\n:::\n:::\n\n\n:::callout-note\nNeed to discuss the `triangles()` parameter. I think the current calculation of\nchange statistics for triangles is incorrect.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(sim$net)\n```\n\n::: {.cell-output-display}\n![](examples_cs_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(paste(\"Number of simulated nodes:\", nrow(sim$ev$nodes)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Number of simulated nodes: 103\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste(\"Number of simulated edges:\", nrow(sim$ev$edges))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Number of simulated edges: 133\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste(\"Number of simulated events:\", sim$events$n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Number of simulated events: 25\"\n```\n\n\n:::\n:::\n\n\nFit CS data. \n\n:::callout-tip\nMake sure to specify the transformation setting for the CS parameters. \n\nIdeally will default to correct value, but want to discuss how we are implementing\nthe arguments, because lowk I like the old way of passing `CS_params` better.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparams_cs_init <- list(\n  mu = 3,\n  K = 1,\n  beta = 1,\n  beta_edges = 1,\n  node_lambda = 5,\n  # CS_edges = -2.5,\n  # CS_triangles = 0.001,\n  CS_star.2 = 0,\n  CS_star.3 = 0\n)\n\nfit <- fit_hawkesNet(\n      ev = sim$ev,\n      params_init = params_cs_init,\n      mark_type = \"cs\",\n      transform = list(CS_star.2 = \"none\", CS_star.3 = \"none\"),\n      formula_rhs = \"star(c(2,3))\"\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Fitting took 74.73 seconds\"\n```\n\n\n:::\n:::\n\n\nParameter values on the fitted scale:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunlist(fit$par)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         mu           K        beta  beta_edges node_lambda   CS_star.2 \n  3.8434437   1.2071197   4.6983466   0.2561687   4.1202448  -1.0297906 \n  CS_star.3 \n -3.1923367 \n```\n\n\n:::\n:::\n\n\n:::callout-note\nYou might notice the estimates for `beta` and `K` are not great. I tried \nincreasing `time` which didn't help (actually made it worse?).\n\nWill definitely be doing some sensitivity testing / experimentation once I've\nimplemented Duncan's supercharged model fitting.\n:::\n\nParameter values on the transformed scale:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit$fit$par\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         mu           K        beta  beta_edges node_lambda   CS_star.2 \n  1.3463688   0.1882371   1.5472107  -1.3619189   1.4159126  -1.0297906 \n  CS_star.3 \n -3.1923367 \n```\n\n\n:::\n:::\n\n\n\n\n",
    "supporting": [
      "examples_cs_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}