{
  "hash": "3f8725c8115cfe6621d97146a26cfff9",
  "result": {
    "engine": "knitr",
    "markdown": "\n\n```{=html}\n<style>\n.vcenter-cols .columns {\n  display: flex;\n  align-items: center;\n  gap: 0.75rem;\n}\n.vcenter-cols .columns .column {\n  flex: 1 1 0;\n}\n</style>\n```\n\n\n# CS-Bipartite Kernel\n\n### Kernel Specification {.unnumbered}\n\nThe CS-Bipartite kernel extends the CS (“change-statistic”) kernel to **bipartite networks**, where nodes belong to two disjoint sets (say **Part A** and **Part B**) and edges may only occur across parts (A–B).\n\nAs in the CS kernel, attachment decisions are driven by **ERGM-style change statistics**, rather than by degree weighting.\n\nAt each event time $t$:\n\n- A random number of **new nodes** arrives:\n  $$\n  M_t \\sim \\text{Poisson}(\\lambda_{\\text{node}}),\n  $$\n  where $\\lambda_{\\text{node}}$ is controlled by `node_lambda`.  \n  Each arriving node is assigned to one of the two bipartite parts (according to the internal sampling mechanism in the simulator).\n\n- Let $V_A(t^-)$ and $V_B(t^-)$ be the existing nodes in Parts A and B immediately before time $t$.\n  Let $N_A(t)$ and $N_B(t)$ be the sets of new nodes arriving into Parts A and B at time $t$.\n\nThe candidate edge set consists of all possible cross-part new–old edges:\n$$\n\\{(u, v): u \\in N_A(t),\\, v \\in V_B(t^-)\\}\n\\;\\cup\\;\n\\{(u, v): u \\in N_B(t),\\, v \\in V_A(t^-)\\}.\n$$\n\nOptionally, the candidate set may be truncated (via the `truncation` argument) to reduce computational cost by limiting how many old nodes each new node is allowed to consider.\n\nFor each candidate edge $(u,v)$, a vector of bipartite change statistics\n$$\nC_{uv}(t)\n$$\nis computed from the current bipartite network using the user-specified ERGM-style formula (via `computeChangeStats()`).\n\nThese are converted into baseline edge probabilities using a logistic link:\n$$\np^{(0)}_{uv}(t) = \\text{logit}^{-1}\\!\\left(C_{uv}(t)^\\top \\theta\\right).\n$$\n\nAs in the other kernels, an aging / recency adjustment is then applied to down-weight older target nodes:\n$$\np_{uv}(t) = p^{(0)}_{uv}(t)\\,\\exp\\!\\big(-\\beta_{\\text{edges}}\\cdot \\text{age}_v(t)\\big),\n$$\nwhere $\\text{age}_v(t) = t - t_v$ is computed from the stored node arrival time.\n\nEach candidate edge is then treated as an independent Bernoulli trial, so the mark probability is a **product of Bernoulli terms** over the bipartite candidate edge set.\n\n---\n\n### Data Expectations {.unnumbered}\n\nTo use the CS-Bipartite kernel, your observed events must represent a **bipartite growth process**, meaning:\n\n- Every node belongs to exactly one of two parts (A or B).\n- Each event time may introduce **zero or more new nodes**.\n- Any edges observed at an event must connect a **new node** to an **already-existing node in the opposite part**.\n\nIn particular, the current CS-Bipartite implementation assumes:\n\n- **No within-part edges** (no A–A or B–B edges).\n- **No old–old edges** (edges cannot form between two already-existing nodes).\n- **No new–new edges** (edges cannot form between two nodes arriving at the same event time).\n- **No self-loops**, and no duplicate edges within a single event.\n\nIf your data contains cross-part edges forming between two already-existing nodes (e.g. repeated interactions between the same two agents over time), then the CS-Bipartite kernel is not an appropriate mark model without extending the mark space / PMF.\n\n---\n\n### Simulation {.unnumbered}\n\nSimulate CS data.\n\n<div class=\"vcenter-cols\">\n::: {.columns}\n::: {.column width=\"40%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\n\ntime <- 10\nparams_cs_bip_true <- list(\n  mu = 2,\n  K = 0.5,\n  beta = 2,\n  beta_edges = 0.5,\n  lambda_new = 2,\n  # CS_edges = -2.5,\n  # CS_triangles = 0.001,\n  CS_star.2 = -1,\n  CS_star.3 = -3\n)\n\nsim <- sim_hawkesNet(\n  params = params_cs_bip_true,\n  T_end = time,\n  mark_type = \"cs_bip\",\n  # formula_rhs = \"edges + triangles() + star(c(2,3))\",\n  formula_rhs = \"star(c(2,3))\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Simulation took 0.3 seconds\"\n```\n\n\n:::\n:::\n\n\n:::\n::: {.column width=\"60%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](examples_cs_bip_files/figure-html/unnamed-chunk-3-1.png){width=100%}\n:::\n:::\n\n\n:::\n:::\n</div>\n\n### Model fitting {.unnumbered}\n\nFit CS data. \n\n:::callout-tip\nMake sure to specify the transformation setting for the CS parameters. \n\nIdeally will default to correct value, but want to discuss how we are implementing\nthe arguments, because lowk I like the old way of passing `CS_params` better.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparams_cs_bip_init <- list(\n  mu = 3,\n  K = 1,\n  beta = 1,\n  beta_edges = 1,\n  lambda_new = 5,\n  # CS_edges = -2.5,\n  # CS_triangles = 0.001,\n  CS_star.2 = 0,\n  CS_star.3 = 0\n)\n\nfit <- fit_hawkesNet(\n      ev = sim$ev,\n      params_init = params_cs_bip_init,\n      mark_type = \"cs_bip\",\n      transform = list(CS_star.2 = \"none\", CS_star.3 = \"none\"),\n      formula_rhs = \"star(c(2,3))\"\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Fitting took 1.08 seconds\"\n```\n\n\n:::\n:::\n\n\nParameter values on the fitted scale:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunlist(fit$par)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        mu          K       beta beta_edges lambda_new  CS_star.2  CS_star.3 \n 2.5895072  1.1255554 14.5240853  0.3912574  1.7407322 -1.6274125  1.1715270 \n```\n\n\n:::\n:::\n\n\n:::callout-note\nEstimates don't look great @_@\n:::\n\nParameter values on the transformed scale:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit$fit$par\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        mu          K       beta beta_edges lambda_new  CS_star.2  CS_star.3 \n 0.9514676  0.1182766  2.6758083 -0.9383895  0.5543058 -1.6274125  1.1715270 \n```\n\n\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## See the simulation study results for the CS-BIP kernel here.\n:::\n\n\n\n",
    "supporting": [
      "examples_cs_bip_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}