{
  "hash": "250010d33067e7c3080591a6d40a6b98",
  "result": {
    "engine": "knitr",
    "markdown": "\n\n```{=html}\n<style>\n.vcenter-cols .columns {\n  display: flex;\n  align-items: center;\n  gap: 0.75rem;\n}\n.vcenter-cols .columns .column {\n  flex: 1 1 0;\n}\n</style>\n```\n\n\n# CS-Bipartite Kernel\n\n### Kernel Specification {.unnumbered}\n\nNodes have two possible classifications / types / modes - events / perps.\n\nEach mark consists of exactly 1 new event node arriving, which connects to old \nperp nodes according to the same degree-based weighting above. Additionally, \neach mark consists of n ~ Pois(lambda_new) perp nodes, which are attached to the \nnew event node.\n\n:::callout-note\nLiterally exactly the same as using the CS kernel, but all you need to do is\nspecify `mark_type = \"cs_bip\"`.\n:::\n\n### Simulation {.unnumbered}\n\nSimulate CS data.\n\n<div class=\"vcenter-cols\">\n::: {.columns}\n::: {.column width=\"40%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\n\ntime <- 10\nparams_cs_bip_true <- list(\n  mu = 2,\n  K = 0.5,\n  beta = 2,\n  beta_edges = 0.5,\n  lambda_new = 2,\n  # CS_edges = -2.5,\n  # CS_triangles = 0.001,\n  CS_star.2 = -1,\n  CS_star.3 = -3\n)\n\nsim <- sim_hawkesNet(\n  params = params_cs_bip_true,\n  T_end = time,\n  mark_type = \"cs_bip\",\n  # formula_rhs = \"edges + triangles() + star(c(2,3))\",\n  formula_rhs = \"star(c(2,3))\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Simulation took 0.46 seconds\"\n```\n\n\n:::\n:::\n\n\n:::\n::: {.column width=\"60%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](examples_cs_bip_files/figure-html/unnamed-chunk-3-1.png){width=100%}\n:::\n:::\n\n\n:::\n:::\n</div>\n\n### Model fitting {.unnumbered}\nFit CS data. \n\n:::callout-tip\nMake sure to specify the transformation setting for the CS parameters. \n\nIdeally will default to correct value, but want to discuss how we are implementing\nthe arguments, because lowk I like the old way of passing `CS_params` better.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparams_cs_bip_init <- list(\n  mu = 3,\n  K = 1,\n  beta = 1,\n  beta_edges = 1,\n  lambda_new = 5,\n  # CS_edges = -2.5,\n  # CS_triangles = 0.001,\n  CS_star.2 = 0,\n  CS_star.3 = 0\n)\n\nfit <- fit_hawkesNet(\n      ev = sim$ev,\n      params_init = params_cs_bip_init,\n      mark_type = \"cs_bip\",\n      transform = list(CS_star.2 = \"none\", CS_star.3 = \"none\"),\n      formula_rhs = \"star(c(2,3))\"\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Fitting took 25.08 seconds\"\n```\n\n\n:::\n:::\n\n\nParameter values on the fitted scale:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunlist(fit$par)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           mu             K          beta    beta_edges    lambda_new \n 2.4983966518  0.0332980081  0.0001602598  0.8190927271  2.1111173873 \n    CS_star.2     CS_star.3 \n-1.2626539339  2.0136466943 \n```\n\n\n:::\n:::\n\n\n:::callout-note\nEstimates don't look great @_@\n:::\n\nParameter values on the transformed scale:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit$fit$par\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        mu          K       beta beta_edges lambda_new  CS_star.2  CS_star.3 \n 0.9156492 -3.4022577 -8.7387146 -0.1995580  0.7472174 -1.2626539  2.0136467 \n```\n\n\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## See the simulation study results for the CS-BIP kernel here.\n:::\n\n\n\n",
    "supporting": [
      "examples_cs_bip_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}