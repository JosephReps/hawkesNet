{
  "hash": "503b5208fc646799765f861859fa79cc",
  "result": {
    "engine": "knitr",
    "markdown": "\n\n```{=html}\n<style>\n.vcenter-cols .columns {\n  display: flex;\n  align-items: center;\n  gap: 0.75rem;\n}\n.vcenter-cols .columns .column {\n  flex: 1 1 0;\n}\n</style>\n```\n\n\n# BA Kernel\n\n### Kernel Specification {.unnumbered}\n\nThe BA kernel is a **new-node attachment** model: at each event time, exactly **one new node** arrives, and it connects to a subset of the **already-existing** nodes.\n\nIn the current `hawkesNet` implementation, the set of attachments is modelled as follows:\n\n- Let $V(t^-)$ be the set of existing (“old”) nodes right before the event at time $t$.\n- For each old node $u \\in V(t^-)$, the new node attaches to $u$ **independently** with probability\n$$\n  p_u(t) \\propto (d_u(t^-) + \\delta)\\,\\exp(-\\beta_{\\text{edges}}\\cdot \\text{age}_u(t)),\n$$\n  where $d_u(t^-)$ is the current degree of $u$, and $\\text{age}_u(t) = t - t_u$ is how long ago node $u$ arrived (using its stored node “time” attribute).\n- The probabilities are normalised over all old nodes so they sum to 1 before forming the Bernoulli probabilities used in the product model.\n\nIntuitively:\n\n- **Higher-degree nodes** are more likely to receive a new connection (preferential attachment).\n- If $\\beta_{\\text{edges}} > 0$, **older nodes are down-weighted** via the exponential term (recency/aging effect).\n- $\\delta$ is a small smoothing constant so degree-zero nodes remain eligible.\n\nUnder this mark model, the probability of observing a particular set of attached old nodes is a **product of Bernoulli terms** over the old node set:\n$$\n\\Pr(\\text{attachments at } t) = \\prod_{u \\in V(t^-)} p_u(t)^{I_u}\\,(1-p_u(t))^{1-I_u},\n$$\nwhere $I_u = 1$ if the new node attached to $u$, and $I_u=0$ otherwise.\n\n---\n\n### Data Expectations {.unnumbered}\n\nTo use the BA kernel, your observed events must match the “new node arrives + connects to existing nodes” pattern:\n\n- **Exactly one new node per event** (one row in the node-arrivals data for each event time).\n- Any edges at that event must connect **that new node** to **existing nodes**.\n- Within an event, you should not have the same old node attached multiple times (i.e., no duplicate new–old pair within the same event).\n\nEdge cases:\n\n- If there are **no existing nodes yet**, the event must have **no edges** (there is nobody to attach to).\n- If your data contains edges between two already-existing nodes, or repeated transactions/multi-edges between the same pair, then this BA mark model is not the right fit without extending the mark space / PMF.\n\n---\n\n### Simulation {.unnumbered}\n\nSimulate BA data:\n\n<div class=\"vcenter-cols\">\n::: {.columns}\n::: {.column width=\"40%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\n\ntime <- 50\nparams_ba_true <- list(\n  mu = 0.5,\n  K = 0.5,\n  beta = 0.5,\n  beta_edges = 2\n)\n\nsim <- sim_hawkesNet(\n  params = params_ba_true,\n  T_end = time,\n  mark_type = \"ba\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Simulation took 2.13 seconds\"\n```\n\n\n:::\n:::\n\n:::\n::: {.column width=\"60%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](examples_ba_files/figure-html/unnamed-chunk-3-1.png){width=100%}\n:::\n:::\n\n:::\n:::\n</div>\n\n### Model fitting {.unnumbered}\n\nFit BA data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparams_ba_init <- list(\n  mu = 1,\n  K = 1,\n  beta = 1,\n  beta_edges = 1\n)\n\nfit <- fit_hawkesNet(\n      ev = sim$ev,\n      params_init = params_ba_init,\n      mark_type = \"ba\"\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Fitting took 5.55 seconds\"\n```\n\n\n:::\n:::\n\n\nParameter values on the fitted scale:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunlist(fit$par)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        mu          K       beta beta_edges \n 1.4169583  0.4623329  0.5102294  2.0408620 \n```\n\n\n:::\n:::\n\n\nNot too bad.\n\nAnd, we can also grab parameter values on the transformed scale:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Yes I know this is a jank way to structure it right now, will fix\nfit$fit$par\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        mu          K       beta beta_edges \n 0.3485126 -0.7714700 -0.6728948  0.7133722 \n```\n\n\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## See the simulation study results for the BA kernel here.\n:::\n\n\n\n\n\n\n\n\n\n\n",
    "supporting": [
      "examples_ba_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}