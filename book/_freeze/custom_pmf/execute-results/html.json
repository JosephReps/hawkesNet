{
  "hash": "c390bea0865049d9b379b914d7023153",
  "result": {
    "engine": "knitr",
    "markdown": "# Custom Kernel PMF\n\nIf you want to add your own custom kernel PMF, I put together a rough \"skeleton\".\n\nI will eventually add some custom-kernel tests to validate whether a new kernel\nis truly a PMF.\n\nOnce you've written it, you just need to update the likelihood function, see below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Template: log PMF for a mark kernel (one event)\n#'\n#' This is a minimal skeleton for implementing a custom mark kernel. A mark\n#' kernel assigns a probability to the observed edge set for a single event at\n#' time `t_k`, conditional on the pre-event network `net` and the event mark\n#' (`new_nodes`, `new_edges`).\n#'\n#' @param net network object, the current network at time t_k\n#' @param new_nodes data.frame with at least column \"id\". Any additional\n#'                  columns will be treated as vertex attributes.\n#' @param new_edges data.frame with at least columns \"i\" and \"j\". Any additional\n#'                  columns will be treated as edge attributes.\n#' @param t_k numeric scalar, the event timestamp\n#' @param params Named list of model parameters (kernel-specific, any others will be \n#'                  ignored).\n#' @param ... Optional kernel-specific arguments (e.g. tuning constants, caches).\n#'\n#' @return A list with:\n#' \\describe{\n#'   \\item{logp}{Scalar log probability of observing `new_edges` (and any other\n#'   mark components) at this event.}\n#'   \\item{edge_probs}{Named numeric vector (or matrix) of attachment\n#'   probabilities for eligible targets. This is returned for debugging /\n#'   diagnostics and may be `NULL` if not meaningful for the kernel.}\n#'   \\item{model_cache}{Optional updated cache object (useful for expensive mark\n#'   models). Include only if you accept/use a cache via `...`.}\n#' }\n#'\n#' @examples\n#' # See log_pmf_ba() for a working implementation.\ncustom_pmf <- function(\n    net,\n    new_nodes,\n    new_edges,\n    t_k,\n    params,\n    ...\n) {\n  stopifnot(inherits(net, \"network\"))\n  stopifnot(length(t_k) == 1L, is.numeric(t_k), is.finite(t_k))\n\n  # Validate your input here, eg:\n  #     - check parameter values are appropriate1\n  #     - check new_nodes and new_edges are possible under the kernel specs\n  # I think it would be hygiene to create a separate \"validate_custom...()\"\n  # but you could just throw it all in here.\n\n  # Alter these to include your expected columns\n  stopifnot(is.data.frame(new_edges), all(c(\"i\", \"j\") %in% names(new_edges))) \n  stopifnot(is.data.frame(new_nodes), all(c(\"id\") %in% names(new_nodes))) \n\n  # Next I would cover your edge cases & compute edge-candidates, e.g\n  #     - There are no existing nodes in the network\n  #     - There are existing nodes, but no elgible edge-candidates\n\n  # And then finally, compute the actual edge probabilities\n  edge_probs <- calculate_custom_edge_probs(net, t_k, params)\n\n  # Placeholder\n  logp <- NA_real_\n\n  return(\n    list(\n      logp = as.numeric(logp),\n      edge_probs = edge_probs\n      )\n    )\n}\n```\n:::\n\n\nAnd updating the likelihood function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n  #...\n  event_times <- events$times$t\n  if (length(event_times) == 0L) return(0)\n\n  if (is.null(T_end)) T_end <- max(event_times)\n  if (T_end < max(event_times)) stop(\"T_end must be >= max event time\")\n\n  # Mark kernel dispatch\n  if (mark_type == \"ba\") {\n    mark_logpmf <- log_pmf_ba\n  } else if (mark_type == \"ba_bip\") {\n    mark_logpmf <- log_pmf_ba_bip\n  } else if (mark_type == \"cs\") {\n    mark_logpmf <- log_pmf_cs\n  } else if (mark_type == \"YOUR CUSTOM PMF GOES HERE\") { # ADD THESE LINES\n    mark_logpmf <- YOUR_CUSTOM_PMF_FUNCTION # ADD THESE LINES\n  } else {\n    stop(\"mark_type must be one of 'ba', 'cs', 'ba_bip', 'YOUR_CUSTOM_PMF'\")\n  }\n  # ...\n```\n:::\n\n\n:::callout-note\nYes definitely a better way to do this, just a temporary solution for now.\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}