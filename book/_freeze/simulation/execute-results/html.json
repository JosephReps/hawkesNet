{
  "hash": "98ee828ed05888e46790ac5dd660651d",
  "result": {
    "engine": "knitr",
    "markdown": "\n\n```{=html}\n<style>\n.vcenter-cols .columns {\n  display: flex;\n  align-items: center;\n  gap: 0.75rem;\n}\n.vcenter-cols .columns .column {\n  flex: 1 1 0;\n}\n</style>\n```\n\n\n# Simulation\n\nSimulation is relatively straightforward for the core kernels (BA, BA_BIP, CS, BIP_CS).\n\nUses the usual hawkes Ogata thinning algorithm.\n\n## Example {.unnumbered}\n\nSimulate data using the `sim_hawkesNet()` function. See `?hawkesNet::sim_hawkesNet` \nfor more information.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\n\nparams_ba <- list(\n  mu = 5,\n  K = 0.5,\n  beta = 0.8,\n  beta_edges = 0.5\n)\n\ntime <- 10\n\nsim <- sim_hawkesNet(\n  params = params_ba,\n  T_end = time,\n  return_ev = TRUE,\n  debug = FALSE,\n  mark_type = \"ba\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Simulation took 0.33 seconds\"\n```\n\n\n:::\n:::\n\n\n## Return value {.unnumbered}\n\nSimulation object contains `events`, `accept_probs`, `net` and `ev`.\n\n### `events` {.unnumbered} \n\nContains the times and number of total events simulated:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(sim$events)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 2\n $ n: int 110\n $ t: num [1:110] 0.151 0.178 0.254 0.534 0.784 ...\n```\n\n\n:::\n:::\n\n\n### `accept_probs` {.unnumbered}\n\nContains the acceptance probabilities from the thinning for each \nevent:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(sim$accept_probs)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n num [1:112] 1 0.998 0.99 0.955 0.987 ...\n```\n\n\n:::\n:::\n\n\n### `net` {.unnumbered}\n\nThe final network created from the events:\n\n\n::: {.cell figure.caption='Realisation of a BA simulation'}\n\n```{.r .cell-code}\nplot(sim$net)\n```\n\n::: {.cell-output-display}\n![](simulation_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nNotice that the `time` attributes are preserved in the network object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsim$net\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Network attributes:\n  vertices = 110 \n  directed = FALSE \n  hyper = FALSE \n  loops = FALSE \n  multiple = FALSE \n  bipartite = FALSE \n  total edges= 121 \n    missing edges= 0 \n    non-missing edges= 121 \n\n Vertex attribute names: \n    time vertex.names \n\n Edge attribute names: \n    time \n```\n\n\n:::\n:::\n\n\n:::callout-tip\nAll the vertex attributes are preserved. Additionally, edge \nattributes are supported, so if custom kernels are written which utilize \nthese later i.e. weighted edges, toggle-able edges etc., the current framework\ndoes not eed to change.\n:::\n\n### `ev` {.unnumbered}\n\nThe `events` object which can be plugged directly into `fit_hawkesNet()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(sim$ev)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 3\n $ times:'data.frame':\t110 obs. of  2 variables:\n  ..$ event_id: int [1:110] 1 2 3 4 5 6 7 8 9 10 ...\n  ..$ t       : num [1:110] 0.151 0.178 0.254 0.534 0.784 ...\n $ nodes:'data.frame':\t110 obs. of  2 variables:\n  ..$ event_id: int [1:110] 1 2 3 4 5 6 7 8 9 10 ...\n  ..$ id      : chr [1:110] \"1\" \"2\" \"3\" \"4\" ...\n $ edges:'data.frame':\t121 obs. of  3 variables:\n  ..$ event_id: int [1:121] 2 3 3 5 6 7 7 8 9 9 ...\n  ..$ i       : chr [1:121] \"1\" \"1\" \"2\" \"2\" ...\n  ..$ j       : chr [1:121] \"2\" \"3\" \"3\" \"5\" ...\n - attr(*, \"class\")= chr [1:2] \"events\" \"list\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "supporting": [
      "simulation_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}