{
  "hash": "6a51b59edace87a61dc682a42191c32c",
  "result": {
    "engine": "knitr",
    "markdown": "\n\n```{=html}\n<style>\n.vcenter-cols .columns {\n  display: flex;\n  align-items: center;\n  gap: 0.75rem;\n}\n.vcenter-cols .columns .column {\n  flex: 1 1 0;\n}\n</style>\n```\n\n\n# BA-Bipartite Kernel\n\n### Kernel Specification {.unnumbered}\n\nThe BA-Bipartite kernel is the bipartite analogue of the BA kernel: the network has two disjoint node sets (say **Part A** and **Part B**), and **edges may only occur across parts** (A–B), never within a part.\n\nAt each event time $t$, exactly **one new node** arrives, and it attaches to a subset of **already-existing nodes in the opposite part** using a normalized degree-based weighting (with optional aging / recency down-weighting).\n\nConcretely:\n\n- Let $V_A(t^-)$ and $V_B(t^-)$ be the sets of existing nodes in Parts A and B just before time $t$.\n- A single new node arrives in exactly one part (either A or B). Denote the new node by $v_{\\text{new}}$ and its part by $P \\in \\{A,B\\}$.\n- The candidate attachment targets are the old nodes in the *other* part:\n  $$\n  V_{\\text{opp}}(t^-) =\n  \\begin{cases}\n    V_B(t^-) & \\text{if } v_{\\text{new}} \\in A,\\\\\n    V_A(t^-) & \\text{if } v_{\\text{new}} \\in B.\n  \\end{cases}\n  $$\n\nFor each candidate target $u \\in V_{\\text{opp}}(t^-)$, the new node attaches to $u$ **independently** with probability\n$$\np_u(t) \\propto (d_u(t^-) + \\delta)\\,\\exp\\!\\big(-\\beta_{\\text{edges}}\\cdot \\text{age}_u(t)\\big),\n$$\nwhere $d_u(t^-)$ is the current (bipartite) degree of $u$ right before time $t$, and $\\text{age}_u(t) = t - t_u$ is time since $u$ arrived (from the stored node time attribute).\n\nThese weights are normalised over $V_{\\text{opp}}(t^-)$ to form Bernoulli probabilities, and the probability of observing a specific attachment set is a **product of Bernoulli terms** over the opposite-part node set:\n$$\n\\Pr(\\text{attachments at } t) = \\prod_{u \\in V_{\\text{opp}}(t^-)} p_u(t)^{I_u}\\,(1-p_u(t))^{1-I_u},\n$$\nwhere $I_u=1$ if an edge between $v_{\\text{new}}$ and $u$ is present at time $t$, and $I_u=0$ otherwise.\n\nIntuitively:\n\n- Nodes in the opposite part with **higher degree** are more likely to receive a new tie (preferential attachment).\n- If $\\beta_{\\text{edges}} > 0$, **older nodes are down-weighted** (recency/aging).\n- $\\delta$ is a small smoothing constant so degree-zero nodes remain eligible.\n\n---\n\n### Data Expectations {.unnumbered}\n\nTo use the BA-Bipartite kernel, your observed events must represent a **bipartite growth process** where:\n\n- Each node belongs to exactly one of two parts (A or B).\n- Each event introduces **exactly one new node** (in either part).\n- Any edges observed at that event must connect the **new node** to **already-existing nodes in the opposite part**.\n\nIn particular, the BA-Bipartite kernel assumes:\n\n- **No within-part edges** (no A–A or B–B edges).\n- **No old–old edges** (edges cannot form between two already-existing nodes).\n- **No new–new edges** (the new node cannot connect to another node that arrives at the same event).\n- Within an event, you should not repeat the same attachment (no duplicate new–old pair).\n\nEdge cases:\n\n- If the opposite part has no existing nodes yet (e.g. $V_{\\text{opp}}(t^-)=\\emptyset$), then the event must have **no edges**.\n\nIf your data contains edges between two already-existing nodes (e.g. repeated interactions/transactions), or edges within the same part, then this BA-Bipartite mark model is not an appropriate fit without extending the mark space / PMF.\n\n---\n\n### Simulation {.unnumbered}\n\nSimulate BIP-BA data.\n\n<div class=\"vcenter-cols\">\n::: {.columns}\n::: {.column width=\"40%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1)\n\ntime <- 10\nparams_bip_true <- list(\n  mu = 0.5,\n  K = 0.5,\n  beta = 0.5,\n  beta_edges = 2,\n  lambda_new = 3.5\n)\n\nsim <- sim_hawkesNet(\n  params = params_bip_true,\n  T_end = time,\n  mark_type = \"ba_bip\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Simulation took 0.19 seconds\"\n```\n\n\n:::\n:::\n\n\n:::\n::: {.column width=\"60%\"}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](examples_ba_bip_files/figure-html/unnamed-chunk-3-1.png){width=100%}\n:::\n:::\n\n\n:::\n:::\n</div>\n\n:::{.callout-note collapse=\"true\"}\n## See the code for this plot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncol_map <- c(\n  event = \"#377EB8\",\n  perp  = \"#E41A1C\"\n)\n\nroles <- network::get.vertex.attribute(sim$net, \"role\")\ncols <- col_map[roles]\n\nop <- par(no.readonly = TRUE)\non.exit(par(op), add = TRUE)\n\n# Add a little bottom space for legend\npar(mar = c(2.5,1,1,1), xaxs = \"i\", yaxs = \"i\")\n\nplot(sim$net, vertex.col = cols)\n\nlegend(\n  \"bottomleft\",\n  legend = c(\"Event\", \"Perp\"),\n  pch = 21,\n  pt.bg = col_map[c(\"event\", \"perp\")],  # fill colour\n  col = \"black\",                        # border colour\n  horiz = TRUE,\n  inset = 0.01,\n  xpd = TRUE,\n  cex = 2,\n  pt.cex = 2.5\n)\n```\n\n::: {.cell-output-display}\n![](examples_ba_bip_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n:::\n\n### Model fitting {.unnumbered}\n\nFit BIP-BA data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparams_bip_init <- list(\n  mu = 1,\n  K = 1,\n  beta = 1,\n  beta_edges = 1,\n  lambda_new = 3.5\n)\n\nfit <- fit_hawkesNet(\n      ev = sim$ev,\n      params_init = params_bip_init,\n      mark_type = \"ba_bip\"\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Fitting took 0.39 seconds\"\n```\n\n\n:::\n:::\n\n\nParameter values on the fitted scale:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunlist(fit$par)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        mu          K       beta beta_edges lambda_new \n 1.3977102  0.4811354  0.9347585  2.1233094  3.2400725 \n```\n\n\n:::\n:::\n\n\nParameter values on the transformed scale:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit$fit$par\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n         mu           K        beta  beta_edges  lambda_new \n 0.33483530 -0.73160664 -0.06746709  0.75297592  1.17559572 \n```\n\n\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## See the simulation study results for the BA-BIP kernel here.\n:::\n\n\n\n",
    "supporting": [
      "examples_ba_bip_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}